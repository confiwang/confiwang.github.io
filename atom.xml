<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜星辰 - 王陈云的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://confiwang.github.io/"/>
  <updated>2020-03-11T13:21:52.990Z</updated>
  <id>http://confiwang.github.io/</id>
  
  <author>
    <name>Confiwang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KVO与KVC详解</title>
    <link href="http://confiwang.github.io/2020/03/11/KVO%E4%B8%8EKVC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://confiwang.github.io/2020/03/11/KVO%E4%B8%8EKVC%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-11T12:51:56.000Z</published>
    <updated>2020-03-11T13:21:52.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><h4 id="什么是KVO"><a href="#什么是KVO" class="headerlink" title="什么是KVO"></a>什么是KVO</h4><blockquote><p>KVO全称Key Value Observing，是苹果提供的一套事件通知机制。</p></blockquote><p>允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于KVO的实现机制，只针对属性才会发生作用，一般继承自NSObject的对象都默认支持KVO。</p><h4 id="KVO原理"><a href="#KVO原理" class="headerlink" title="KVO原理"></a>KVO原理</h4><blockquote><p>在运行时创建一个原类的子类，有固定格式 NSKVONotifying_原类名称，将对象的isa指针指向新创建的类，重写 NSKVONotifying_原类名称 的-class方法，返回原类的Class.</p></blockquote><h5 id="为KVO类增加中间层"><a href="#为KVO类增加中间层" class="headerlink" title="为KVO类增加中间层"></a>为KVO类增加中间层</h5><ul><li>生成中间对象 NSKVONotifying_原类名称<ol><li>通过object_getClass得到的是生成的中间对象NSKVONotify_BFPerson，而不是BFPerson。</li><li>要想获得该类真实的对象，需要通过class对象方法获取。上面提到了NSKVONotify_BFPerson会重写其class对象方法，返回的是BFPerson。<br><img src="create.jpg" alt="create"></li></ol></li><li>调用监听的属性设置方法<ol><li>如setAge:，都会先调用NSKVONotify_BFPerson对应的属性设置方法。</li><li>调用非监听属性设置方法，如test，会通过NSKVONotify_BFPerson的superclass，找到BFPerson类对象，再调用其[BFPerson test]方法<br><img src="isa.jpg" alt="isa"></li></ol></li></ul><h5 id="KVO执行流程"><a href="#KVO执行流程" class="headerlink" title="KVO执行流程"></a>KVO执行流程</h5><blockquote><p>通过增加的中间层，在类的set/get方法调用前后增加逻辑，主要实现在[Foundation _NSSetLongLongValueAndNotify]方法中</p></blockquote><p><img src="run.jpg" alt="run"></p><h5 id="触发线程"><a href="#触发线程" class="headerlink" title="触发线程"></a>触发线程</h5><blockquote><p>KVO行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者Run-loop的处理。手动或者自动调用 -didChange… 会触发KVO通知。</p></blockquote><ul><li>KVO是同步运行的这个特性非常强大，只要我们在单一线程上面运行（比如主队列 main queue），KVO会保证下列两种情况的发生：<br>首先，如果我们调用一个支持KVO的setter方法，如下所示：self.exchangeRate = 2.345<ol><li>KVO 能保证所有 exchangeRate 的观察者在 setter 方法返回前被通知到。</li><li>如果某个键被观察的时候附上了 NSKeyValueObservingOptionPrior 选项，直到 -observe… 被调用之前， exchangeRate的accessor方法都会返回同样的值。</li></ol></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="Demo代码"><a href="#Demo代码" class="headerlink" title="Demo代码"></a>Demo代码</h5><ul><li><p>注册观察者</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person1 addObserver:self forKeyPath:@<span class="string">"age"</span> options:option context:@<span class="string">"age chage"</span>];</span><br></pre></td></tr></table></figure></li><li><p>监听回调</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动触发</p><ol><li><p>禁用自动调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对每个属性，KVO都会生成一个‘+ (BOOL)automaticallyNotifiesObserversOfXXX’方法，返回是否可以自动调用KVO</span></span><br><span class="line"><span class="comment">//假如实现上述方法，我们会发现，此时改变age属性的值，无法触发KVO，还需要实现手动调用才能触发KVO。</span></span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversOfAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动调用实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(NSInteger)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_age != age) &#123;</span><br><span class="line">        [self willChangeValueForKey:@<span class="string">"age"</span>];</span><br><span class="line">        _age = age;</span><br><span class="line">        [self didChangeValueForKey:@<span class="string">"age"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>1&amp;2两步合并写法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//age不需要自动调用，age属性之外的（含name）自动调用</span></span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    BOOL automatic = NO;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:@<span class="string">"age"</span>]) &#123;</span><br><span class="line">        automatic = NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>移除观察者</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person1 removeObserver:self forKeyPath:@<span class="string">"age"</span>];</span><br></pre></td></tr></table></figure></li></ul><h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h5><h6 id="keyPath字符串的弊端"><a href="#keyPath字符串的弊端" class="headerlink" title="keyPath字符串的弊端"></a>keyPath字符串的弊端</h6><blockquote><p>在注册Observe时，传入keyPath为字符串类型，keyPath极容易误写。</p></blockquote><ul><li>优化的方案  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person1 addObserver:self forKeyPath:NSStringFromSelector(@selector(age)) options:option context:@<span class="string">"age change"</span>];</span><br></pre></td></tr></table></figure></li></ul><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li>你可以在 lldb 里查看一个被观察对象的所有观察信息。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [observedObject observationInfo]</span><br></pre></td></tr></table></figure></li></ul><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><h4 id="什么是KVC"><a href="#什么是KVC" class="headerlink" title="什么是KVC"></a>什么是KVC</h4><blockquote><p>KVC 允许我们用属性的字符串名称来访问属性，字符串在这儿叫做键。</p></blockquote><ul><li><p>最简单的 KVC 能让我们通过以下的形式访问属性：@property (nonatomic, copy) NSString *name;</p><ol><li><p>实现获取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *n = [object valueForKey:@<span class="string">"name"</span>]</span><br></pre></td></tr></table></figure></li><li><p>实现设置值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object setValue:@<span class="string">"Daniel"</span> forKey:@<span class="string">"name"</span>]</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是这个不仅可以访问OC对象属性，而且也能访问一些C类型变量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：@property (nonatomic) CGFloat height;<br>我们可以这样设置它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object setValue:@(<span class="number">20</span>) forKey:@<span class="string">"height"</span>]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>键路径（Key Path）</p><ol><li>KVC 同样允许我们通过关系来访问对象。假设 person 对象有属性 address，address 有属性 city，我们可以这样通过 person 来访问 city：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person valueForKeyPath:@<span class="string">"address.city"</span>]</span><br></pre></td></tr></table></figure></li></ol></li><li><p>集合的操作</p><ol><li><p>一个常常被忽视的 KVC 特性是它对集合操作的支持。举个例子，我们可以这样来获得一个数组中最大的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *a = @[@<span class="number">4</span>, @<span class="number">84</span>, @<span class="number">2</span>];</span><br><span class="line">NSLog(@<span class="string">"max = %@"</span>, [a valueForKeyPath:@<span class="string">"@max.self"</span>]);</span><br></pre></td></tr></table></figure></li><li><p>或者说，我们有一个 Transaction 对象的数组，对象有属性 amount 的话，我们可以这样获得最大的 amount：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *a = @[transaction1, transaction2, transaction3];</span><br><span class="line">NSLog(@<span class="string">"max = %@"</span>, [a valueForKeyPath:@<span class="string">"@max.amount"</span>]);</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="变量查找逻辑"><a href="#变量查找逻辑" class="headerlink" title="变量查找逻辑"></a>变量查找逻辑</h4><blockquote><p>KVC操作变量有可能增加耗时</p></blockquote><h5 id="变量get操作执行顺序"><a href="#变量get操作执行顺序" class="headerlink" title="变量get操作执行顺序"></a>变量get操作执行顺序</h5><ol><li>按照get&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;、_&lt;key&gt;顺序查找对象中是否有对应的方法<ul><li>如果有则调用getter，执行第5步</li><li>如果没有找到，跳转到第2步</li></ul></li><li>查找是否有countOf&lt;Key&gt;和objectIn&lt;Key&gt;AtIndex: 方法(对应于NSArray类定义的原始方法)以及<key>AtIndexes: 方法(对应于NSArray方法objectsAtIndexes:)<ul><li>如果找到其中的第一个(countOf&lt;Key&gt;)，再找到其他两个中的至少一个，则创建一个响应所有 NSArray方法的代理集合对象，并返回该对象(即要么是countOf&lt;Key&gt; + objectIn&lt;Key&gt;AtIndex:，要么是countOf&lt;Key&gt; + <key>AtIndexes:，要么是countOf&lt;Key&gt; + objectIn&lt;Key&gt;AtIndex: + &lt;key&gt;AtIndexes:)</key></li><li>如果没有找到，跳转到第3步</li></ul></key></li><li>查找名为countOf&lt;Key&gt;、enumeratorOf&lt;Key&gt;和 memberOf<key>这三个方法(对应于NSSet类定义的原始方法）<ul><li>如果找到这三个方法，则创建一个响应所有NSSet方法的代理集合对象，并返回该对象</li><li>如果没有找到，跳转到第4步</li></ul></key></li><li>判断accessInstanceVariablesDirectly<ul><li>为YES时按照_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的顺序查找成员变量，找到了就取值</li><li>为NO时跳转第6步</li></ul></li><li>判断取出的属性值<ul><li>属性值是对象，直接返回</li><li>属性值不是对象，但是可以转化为NSNumber类型，则将属性值转化为NSNumber 类型返回</li><li>属性值不是对象，也不能转化为NSNumber类型，则将属性值转化为NSValue类型返回</li></ul></li><li>调用valueForUndefinedKey:。默认情况下会引发一个异常，但是继承于NSObject的子类可以重写该方法就可以避免崩溃并做出相应措施</li></ol><h5 id="变量set操作执行顺序"><a href="#变量set操作执行顺序" class="headerlink" title="变量set操作执行顺序"></a>变量set操作执行顺序</h5><ol><li>按set&lt;Key&gt;:、_set&lt;Key&gt;:顺序查找对象中是否有对应的方法<ul><li>找到了直接调用设值</li><li>没有找到跳转第2步</li></ul></li><li>判断accessInstanceVariablesDirectly结果<ul><li>为YES时按照_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的顺序查找成员变量，找到了就赋值，找不到就跳转第3步</li><li>为NO时跳转第3步</li></ul></li><li>调用setValue：forUndefinedKey:。默认情况下会引发一个异常，但是继承于NSObject的子类可以重写该方法就可以避免崩溃并做出相应措施</li></ol><h4 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="简化列表UI"><a href="#简化列表UI" class="headerlink" title="简化列表UI"></a>简化列表UI</h5><blockquote><p>通过字符串匹配，批量更新属性值</p></blockquote><ul><li><p>假设我们有这样一个对象：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Contact : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *nickname;</span><br><span class="line">@property (nonatomic, copy) NSString *email;</span><br><span class="line">@property (nonatomic, copy) NSString *city;</span><br><span class="line"></span><br><span class="line">@<span class="built_in">end</span></span><br></pre></td></tr></table></figure></li><li><p>还有一个 detail 视图控制器，含有四个对应的 UITextField 属性：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">interface <span class="title">DetailViewController</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *nameField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *nicknameField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *emailField;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *cityField;</span><br><span class="line"></span><br><span class="line">@<span class="built_in">end</span></span><br></pre></td></tr></table></figure></li><li><p>我们可以简化更新 UI 的逻辑。首先我们需要两个方法：一个返回 model 里我们用到的所有键的方法，一个把键映射到对应的文本框的方法：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)contactStringKeys;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @[@<span class="string">"name"</span>, @<span class="string">"nickname"</span>, @<span class="string">"email"</span>, @<span class="string">"city"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITextField *)textFieldForModelKey:(NSString *)key;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [self valueForKey:[key stringByAppendingString:@<span class="string">"Field"</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有了这个，我们可以从 model 里更新文本框，如下所示：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateTextFields;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (NSString *key in self.contactStringKeys) &#123;</span><br><span class="line">        [self textFieldForModelKey:key].<span class="built_in">text</span> = [self.contact valueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们也可以用一个 action 方法让四个文本框都能实时更新 model：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：我们之后会添加验证输入的部分，在键值验证里会提到。</span></span><br><span class="line">- (IBAction)fieldEditingDidEnd:(UITextField *)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (NSString *key in self.contactStringKeys) &#123;</span><br><span class="line">        UITextField *field = [self textFieldForModelKey:key];</span><br><span class="line">        <span class="keyword">if</span> (field == sender) &#123;</span><br><span class="line">            [self.contact setValue:sender.<span class="built_in">text</span> forKey:key];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们需要确认文本框在需要的时候被更新：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(BOOL)animated;</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    [self updateTextFields];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setContact:(Contact *)contact</span><br><span class="line">&#123;</span><br><span class="line">    _contact = contact;</span><br><span class="line">    [self updateTextFields];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="修改系统控件属性"><a href="#修改系统控件属性" class="headerlink" title="修改系统控件属性"></a>修改系统控件属性</h5><blockquote><p>系统控件头文件，可控制的变量无法满足要求，寻找更多属性配置</p></blockquote><ul><li><p>通过runtime获取系统空间的变量列表，以NSImageView为例</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u_int count;</span><br><span class="line"><span class="keyword">objc_property_t</span> *properties =class_copyPropertyList([NSImageView class], &amp;count);</span><br><span class="line">NSMutableArray *propertiesArray = [NSMutableArray arrayWithCapacity:count];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* propertyName = property_getName(properties[i]);</span><br><span class="line">    MMInfo(@<span class="string">"属性%@\n"</span>,[NSString stringWithUTF8String: propertyName]);</span><br><span class="line">    [propertiesArray addObject: [NSString stringWithUTF8String: propertyName]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到属性列表，看到placeholderImage字段<br>  <img src="var.jpg" alt="var"></p></li><li><p>更改私有量的placeholderImage值，实现默认图片设置</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self setValue:[NSImage imageNamed:@<span class="string">"WeChatLogo"</span>] forKey:@<span class="string">"placeholderImage"</span>];</span><br></pre></td></tr></table></figure></li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://juejin.im/post/5d34738df265da1bb97019fa" target="_blank" rel="noopener">Objective-C（九）KVC与KVO</a><br><a href="https://objccn.io/issue-7-3/" target="_blank" rel="noopener">KVC 和 KVO</a><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">Key-Value Coding Programming Guide</a><br><a href="https://juejin.im/post/5e5e06ba51882549063a9011" target="_blank" rel="noopener">iOS探索 KVC原理及自定义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;h4 id=&quot;什么是KVO&quot;&gt;&lt;a href=&quot;#什么是KVO&quot; class=&quot;headerlink&quot; title=&quot;什么是KVO&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="底层探索" scheme="http://confiwang.github.io/categories/%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="macOS" scheme="http://confiwang.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O文件学习与应用</title>
    <link href="http://confiwang.github.io/2020/03/10/Mach-O%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://confiwang.github.io/2020/03/10/Mach-O%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-10T14:10:32.000Z</published>
    <updated>2020-03-10T14:39:34.540Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mach-O文件"><a href="#Mach-O文件" class="headerlink" title="Mach-O文件"></a>Mach-O文件</h4><blockquote><p>运行时可执行文件的文件类型</p></blockquote><ul><li>包含以下几种类型<ol><li>Executable—Main binary for application</li><li>Dylib—Dynamic library (aka DSO or DLL)</li><li>Bundle—Dylib that cannot be linked, only dlopen(), e.g. plug-ins</li><li>Image—An executable, dylib, or bundle</li><li>ramework—Dylib with directory for resources and headers</li></ol></li></ul><ul><li>常见的段跟区<br>  <img src="segment.jpg" alt="segment"><br>  <img src="malloc.jpg" alt="malloc"></li></ul><h4 id="APP加载过程"><a href="#APP加载过程" class="headerlink" title="APP加载过程"></a>APP加载过程</h4><blockquote><p>从exec()到main()</p></blockquote><h5 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h5><p>内核将你的APP映射到一个随机的地址（ASLR）</p><h5 id="加载Dyld"><a href="#加载Dyld" class="headerlink" title="加载Dyld"></a>加载Dyld</h5><blockquote><p>内核将加载可执行文件任务交给dyld，Dyld 是一个辅助程序，从程序的entry point开始加载</p></blockquote><ul><li>主要功能<ol><li>加载所有依赖库；</li><li>修复所有DATA页面的指针；</li><li>运行所有构造器初始化，并最终调用 mian()。</li></ol></li></ul><h5 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h5><h6 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h6><blockquote><p>任何问题都可以通过增加一个中间层来解决</p></blockquote><p>虚拟地址空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，最初创建的时候并没有映射任何物理空间，在i386的Linux下，创建进程虚拟地址空间实际只是分配一个页目录，映射关系等到后面程序发生页错误的时候再进行设置。</p><h6 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h6><blockquote><p>物理空间-虚拟空间-可执行文件间的映射关系</p></blockquote><p>当程序发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该页“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。但是很明显的一点是，当操作系统捕获到缺页错误时，它应当知道程序当前所需要的的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。</p><ul><li><p>VMA（Virtual Memory Area）<br>  Linux中将进程虚拟空间中的一个段叫做虚拟内存区域，VMA是进程的数据结构，用于保存虚拟空间与可执行文件的映射关系，以及页的属性等。当发生页错误时，操作系统通过VMA计算出“缺页”在可执行文件中的偏移。</p></li><li><p>执行过程<br>  操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。从进程的角度看可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。</p></li><li><p>页错误处理<br>  当CPU开始打算执行一个地址指令时，发现页面0x08048000~0x08049000是空页面，于是它认为这是一个页错误。CPU将控制权交给操作系统，操作系统将查询第二步建立的数据结构（虚拟空间与可执行文件的映射关系），然后找到VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权交回给进程，进程从刚才错误页位置重新开始执行。</p></li><li><p>EFL装载执行过程</p><ol><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li></ol></li><li><p>可执行文件，进程虚拟地址空间，物理空间三者之间的关系<br>  <img src="load.jpg" alt="load"><br>  程序入口地址0x08048000</p></li><li><p>可执行文件内容<br>  可执行文件中包含的往往不止代码段，还有数据段，BSS（未初始化的变量，不占用内存空间）等，所以映射到进程虚拟空间的往往不止一个段。</p></li><li><p>段的整合<br>  ELF文件被映射时，是以系统的页长度作为单位的，每个段在映射时的长度是系统页的整数倍，，如果不是，那么多余的部分也将占用一个页。一个ELF文件中往往有十几个段，那么内存空间的浪费是可想而知的。<br>  当我们站在操作系统的角度看问题时，可以发现实际上它并不关心可执行文件各个段所包含的内容，操作系统只关心一些跟装载相关的问题，最主要的是段的权限（可读，可写，可执行）。ELF文件中，段的权限往往只有为数不错的几种组合，基本上是三种：</p><ul><li><p>以代码段为代表的权限为可读可执行的段。</p></li><li><p>以数据段和BSS段位代表的权限为可读可写的段。</p></li><li><p>以只读数据段为代表的权限为只读的段。</p><p>那么，我们可以找到的一个简单的方法：对于相同权限的段，把他们合并到一起当做一个段进行映射。</p></li></ul></li><li><p>Segment<br>  一个Segment包含一个或多个属性类似的Section，装载时可以将他们看成一个整体一起映射，也就是说映射以后在进程虚拟空间中只有一个相对于的VMA，这样做的好处是可以明显减少内存碎片。<br>  Segment实际上从装载的角度重新划分了ELF的各个段。</p></li><li><p>Code Sign</p><ol><li>每一页都被单独加密</li><li>每一页在读取的时候都单独校验</li></ol></li></ul><h5 id="Dyld加载其他动态库"><a href="#Dyld加载其他动态库" class="headerlink" title="Dyld加载其他动态库"></a>Dyld加载其他动态库</h5><blockquote><p>加载所有的依赖库文件</p></blockquote><p>Dyld从主执行文件的header获取到需要加载的所依赖动态库列表，然后它需要找到每个 dylib，而应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以所需要加载的是动态库列表一个递归依赖的集合</p><h5 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h5><blockquote><p>在Image内部调整指针的指向。</p></blockquote><p>在过去，会把动态库加载到指定地址，所有指针和数据对于代码都是对的，而现在地址空间布局是随机化，ASLR(Address space layout randomization)使所有动态库被加载到随机地址上，所以需要在原来的地址根据随机的偏移量做一下修正</p><h5 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h5><blockquote><p>调整指向Image外部的dylib内容的指针。</p></blockquote><p>这些指向外部的指针被符号(symbol)名称绑定，dyld需要去符号表里查找，找到symbol对应的实现</p><h5 id="Notify-ObjC-Runtime"><a href="#Notify-ObjC-Runtime" class="headerlink" title="Notify ObjC Runtime"></a>Notify ObjC Runtime</h5><blockquote><p>动态语言额外操作</p></blockquote><ul><li>注册Objc类 (class registration)，ObjC 需要维护一张包含所有类与其映射的表格。</li><li>把category的定义插入方法列表 (category registration)</li><li>保证每一个selector唯一 (selector uniquing)</li></ul><h5 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h5><blockquote><p>类初始化</p></blockquote><ul><li>Objc的+load()函数</li><li>C++的构造函数属性函数</li><li>非基本类型的C++静态全局变量的创建(通常是类或结构体)</li></ul><h5 id="mian"><a href="#mian" class="headerlink" title="mian()"></a>mian()</h5><blockquote><p>应用程序入口</p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="APP启动时间"><a href="#APP启动时间" class="headerlink" title="APP启动时间"></a>APP启动时间</h5><blockquote><p>main()函数执行前的耗时优化</p></blockquote><ul><li>只需要在Edit scheme-&gt;Run-&gt;Environment Variables中将环境变量DYLD_PRINT_STATISTICS设为1，就可以看到main之前各个阶段的时间消耗<br>  <img src="set.jpg" alt="set"></li><li>相关优化点：<ol><li>动态库加载越多，启动越慢。</li><li>ObjC类，方法越多，启动越慢。</li><li>ObjC的+load越多，启动越慢。</li><li>C的constructor函数越多，启动越慢。</li><li>C++静态对象越多，启动越慢。</li><li>建议使用swift</li><li>dlopen()不建议使用</li></ol></li><li>线上启动时间起点获取<br>  以App的进程创建时间（即exec函数执行时间）作为冷启动的起始时间。因为系统允许我们通过sysctl函数获得进程的有关信息，其中就包括进程创建的时间戳。</li></ul><h5 id="代码瘦身"><a href="#代码瘦身" class="headerlink" title="代码瘦身"></a>代码瘦身</h5><blockquote><p>因为OC是动态原因，编译的时候并不会主动删除没有被使用的类。</p></blockquote><ul><li><p>删除无用的类<br>通过对Mach-O文件的了解，可以知道<strong>TEXT:</strong>objc_methname:中包含了代码中的所有方法，而<strong>DATA</strong>objc_selrefs中则包含了所有被使用的方法的引用，通过取两个集合的差集就可以得到所有未被使用的方法</p></li><li><p>删除无用的方法<br>分析Mach-o文件中的__DATA __objc_selrefs段得到使用到的方法，通过otool找出实现的所有方法。取差集得到未使用的方法。然后过滤setter和getter，过滤协议方法，再加上一些其它的过滤规则得到最终的结果。</p></li></ul><h5 id="查看Mach—O文件相关信息"><a href="#查看Mach—O文件相关信息" class="headerlink" title="查看Mach—O文件相关信息"></a>查看Mach—O文件相关信息</h5><ul><li><p>查看Mach-O文件依赖的库文件<br>  xcrun dyldinfo -dylibs filename</p></li><li><p>使用MachOExplorer查看Mach-O文件的header结构<br>  <img src="mach-o.jpg" alt="mach-o"></p></li><li><p>可执行文件中加载的lib<br>  包含了objc的runtime（可以通过编写测试程序得知，下图分析的是微信的可执行文件，添加的动态链接库稍多）<br>  <img src="lib.jpg" alt="lib"></p></li><li><p>查看架构是32位的还是64位的<br>  <img src="32or64.jpg" alt="32or64"></p></li><li><p>查看可执行文件各个段的信息<br>  参数-x展示详细信息</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h WeChat.app/Contents/MacOS/WeChat</span><br></pre></td></tr></table></figure></li><li><p>查看可执行文件的代码段，数据段，BSS段的长度<br>  dec字段表示段长度和的十进制 ，hex表示长度和的十六进制</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span> WeChat.app/Contents/MacOS/WeChat</span><br></pre></td></tr></table></figure></li><li><p>查看framework的架构</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -info andromeda.framework/andromeda</span><br></pre></td></tr></table></figure></li><li><p>按架构拆分framework</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo xxx.framework/xxx -thin i386 xxx.i386</span><br></pre></td></tr></table></figure></li><li><p>根据方法名查找对应的目标文件</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -t libogg.a <span class="comment">//需要有对应的符号表</span></span><br></pre></td></tr></table></figure><p>  <img src="dump.jpg" alt="dump"></p></li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">Optimizing App Startup Time</a><br><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html" target="_blank" rel="noopener">美团外卖iOS App冷启动治理</a><br><a href="https://juejin.im/post/5d5d1a92e51d45620923886a" target="_blank" rel="noopener">iOS代码瘦身实践:删除无用的类</a><br><a href="https://juejin.im/post/5d6482b0e51d456209238885" target="_blank" rel="noopener">iOS代码瘦身实践:删除无用的方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Mach-O文件&quot;&gt;&lt;a href=&quot;#Mach-O文件&quot; class=&quot;headerlink&quot; title=&quot;Mach-O文件&quot;&gt;&lt;/a&gt;Mach-O文件&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;运行时可执行文件的文件类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="底层探索" scheme="http://confiwang.github.io/categories/%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="macOS" scheme="http://confiwang.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>macOS 10.15截图权限检测</title>
    <link href="http://confiwang.github.io/2020/01/08/macOS%2010-15%E6%88%AA%E5%9B%BE%E6%9D%83%E9%99%90%E6%A3%80%E6%B5%8B/"/>
    <id>http://confiwang.github.io/2020/01/08/macOS%2010-15%E6%88%AA%E5%9B%BE%E6%9D%83%E9%99%90%E6%A3%80%E6%B5%8B/</id>
    <published>2020-01-08T13:59:57.000Z</published>
    <updated>2020-01-08T14:31:36.590Z</updated>
    
    <content type="html"><![CDATA[<h4 id="屏幕录制权限缺失"><a href="#屏幕录制权限缺失" class="headerlink" title="屏幕录制权限缺失"></a>屏幕录制权限缺失</h4><p>macOS 10.15苹果加强了权限管理，如果你的APP需要获取其他APP的界面，需要用户主动在系统“偏好设置-安全性与隐私-屏幕录制-勾选对应APP“，但是有很多用户不知道这个额外操作，导致APP的功能出现在这些用户的电脑中不可用的情况，具体功能比如应用无法获取屏幕截图，只能截取本APP的界面。</p><h4 id="屏幕录制权限跳转"><a href="#屏幕录制权限跳转" class="headerlink" title="屏幕录制权限跳转"></a>屏幕录制权限跳转</h4><p>这个时候，我们就需要去提示用户执行上述中的权限赋予操作，权限赋予操作可以使用如下代码实现。(下图中的URL Scheme的获取也是一门技术活，有兴趣的同学可以看看)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURL *URL = [NSURL URLWithString:@&quot;x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture&quot;];</span><br><span class="line">[[NSWorkspace sharedWorkspace] openURL:URL];</span><br></pre></td></tr></table></figure><h4 id="屏幕录制权限判断"><a href="#屏幕录制权限判断" class="headerlink" title="屏幕录制权限判断"></a>屏幕录制权限判断</h4><p>但是会有一个问题，我们什么时候去弹出这个权限控制框，我们需要对APP是否获取屏幕录制权限做一个判断。上述问题通过 <a href="https://developer.apple.com/videos/play/wwdc2019/701/?time=1007" target="_blank" rel="noopener">WWDC 2019 Advances in macOS Security</a> 找到了答案。<br>下面是该视频中的一段文字摘要，清楚的表达了如何去判断APP是否获得了屏幕录制权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the window name and sharing state are not available, unless the user has preapproved the app for screen recording. And this is because some apps put sensitive data such as account names or more likely web page URLs in the window&apos;s name.</span><br></pre></td></tr></table></figure><p>上面大意就是当用户没有屏幕录制权限时，其他APP的窗口名称跟共享状态是不可用的。更详细的信息，大家可以去看一下这期WWDC的视频，着急的话，看文字版就好。<br>接下来就是根据这段文字翻译而成的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)ScreeningRecordPermissionCheck &#123;</span><br><span class="line">    if (@available(macOS 10.15, *)) &#123;</span><br><span class="line">        CFArrayRef windowList = CGWindowListCopyWindowInfo(kCGWindowListOptionOnScreenOnly, kCGNullWindowID);</span><br><span class="line">        NSUInteger numberOfWindows = CFArrayGetCount(windowList);</span><br><span class="line">        NSUInteger numberOfWindowsWithInfoGet = 0;</span><br><span class="line">        for (int idx = 0; idx &lt; numberOfWindows; idx++) &#123;</span><br><span class="line"></span><br><span class="line">            NSDictionary *windowInfo = (NSDictionary *)CFArrayGetValueAtIndex(windowList, idx);</span><br><span class="line">            NSString *windowName = windowInfo[(id)kCGWindowName];</span><br><span class="line">            NSNumber* sharingType = windowInfo[(id)kCGWindowSharingState];</span><br><span class="line"></span><br><span class="line">            if (windowName || kCGWindowSharingNone != sharingType.intValue) &#123;</span><br><span class="line">                numberOfWindowsWithInfoGet++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSNumber* pid = windowInfo[(id)kCGWindowOwnerPID];</span><br><span class="line">                NSString* appName = windowInfo[(id)kCGWindowOwnerName];</span><br><span class="line">                NSLog(@&quot;windowInfo get Fail pid:%lu appName:%@&quot;, pid.integerValue, appName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFRelease(windowList);</span><br><span class="line">        if (numberOfWindows == numberOfWindowsWithInfoGet) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过屏幕录制权限的判断以及跳转，已经可以完美解决本次macOS 10.15更新带来的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;屏幕录制权限缺失&quot;&gt;&lt;a href=&quot;#屏幕录制权限缺失&quot; class=&quot;headerlink&quot; title=&quot;屏幕录制权限缺失&quot;&gt;&lt;/a&gt;屏幕录制权限缺失&lt;/h4&gt;&lt;p&gt;macOS 10.15苹果加强了权限管理，如果你的APP需要获取其他APP的界面，需要用户主
      
    
    </summary>
    
    
      <category term="小伎俩" scheme="http://confiwang.github.io/categories/%E5%B0%8F%E4%BC%8E%E4%BF%A9/"/>
    
    
      <category term="macOS" scheme="http://confiwang.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>我的2019年</title>
    <link href="http://confiwang.github.io/2020/01/01/%E6%88%91%E7%9A%842019%E5%B9%B4/"/>
    <id>http://confiwang.github.io/2020/01/01/%E6%88%91%E7%9A%842019%E5%B9%B4/</id>
    <published>2020-01-01T03:49:03.000Z</published>
    <updated>2020-01-01T03:56:17.250Z</updated>
    
    <content type="html"><![CDATA[<p>原本打算在2019年写的，一眨眼就从2019年写到了2020年，时间可过得真快~<br>回首过去，已经工作了四个多年头。感叹时间不会因为我而停止的同时，看看我这一年，时间都去哪了~</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><blockquote><p>在深圳并没有家庭</p></blockquote><h4 id="女朋友"><a href="#女朋友" class="headerlink" title="女朋友"></a>女朋友</h4><blockquote><p>拥有了一个目标。</p></blockquote><p>回想这一年最开心的事情，在2019年的尾巴，找到了我喜欢的人，一起散步，一起遛狗，一起探店，一起爬山，一起看电影，一起学习。。。应该说看她学习，跟她在一起，我真的没办法静下心来，她真的很优秀，没有缺点，是一个我愿意陪着走完一生的人，不幸的是，上面的话并不是她说的。</p><h4 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h4><blockquote><p>错失人生前26年收益最大的一笔投资。</p></blockquote><p>之前有想过在深圳买房，自己很喜欢的一个小区，恰好有一套房子业主急卖，因为我不是很急，想着周末再过去看看房子怎么样，结果在周内就有客户，没有还价就要了这套房子。<br>这个对我打击好大，后来也没有再看房了（在深圳，我喜欢的小区就那么一个），买房对我来说确实不是一件很容易的事情，事实证明我的眼光确实不错，现在那套房子，涨了至少百分之四十吧，是深圳这一年涨的最多的区域，没有之一。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><blockquote><p>温水煮青蛙</p></blockquote><h4 id="T9"><a href="#T9" class="headerlink" title="T9"></a>T9</h4><blockquote><p>接受挑战</p></blockquote><p>公司每年有两次晋升的机会，需要在三位大佬面前陈述你最得意的地方，并接受挑战。作为一个开发人员，从T8-&gt;T9是一个坎，这么说，似乎不是很形象，我还是喜欢用之前的方式，工程师-&gt;高级工程师，来表述它~<br>我想，晋级前我应该是最不被看好的那个吧，连续两次三星（如果说腾讯滨海大厦掉下一块玻璃，并且刚好要砸到一个腾讯人的话，那么这个人的考核，很大概率是三星）。我不是一个破釜沉舟，然后战斗力爆表的人，不过好在我也不是一个破罐子破摔的人，永远都不会失去梦想。<br>回想答辩的那段时光，我以为晋级之后的我会喜出望外，事实上我对结果是麻木的，反而是准备答辩PPT的那段日子，让我热血沸腾，一路准备的过程中，在心底也留下许多人的温暖，peace&amp;love。</p><h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><blockquote><p>从未实现且万年不变的目标。</p></blockquote><h4 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h4><blockquote><p>初出茅庐</p></blockquote><p>从峰值的91.0KG-&gt;83.3KG，用我妈的话说，应该减掉了一脸盆的猪肉。。。<br>今年的健身活动比往年多了很多，也加入了一些新的东西，比如私教课，Apple Watch，现在买东西，都会跟私教课挂钩，我想，如果我可以坚持运动一个月，那么这个Apple Watch就回本了，现在看来，买Apple Watch收益率已经到了百分之一百五，并且在持续增长。<br>今年的健身活动其实开展了两次，一次是在年初二月十九，持续了五个月，最终定格在86.9KG，期间参加了十一节八人团课，第二次是在十一月十八，现在还在持续进行中，已经参加了十一节一对一私教课，对身体各个部位肌肉的训练也初窥门径，现在想想，健身可能真的是一个人的事情，同时，私教课价格是真的贵，也让我立下的为健身消费一万元的目标越来越近了，我应该从来不会想到，花钱也不是一件容易的事情，而且，长大了，真的会花钱买罪受。</p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><blockquote><p>不太好意思讲</p></blockquote><p>看了有记载的阅读记录，今年看的书是真的少，把说明书也算上的话，平均一个月不到一本。</p><h4 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h4><blockquote><p>妥协并不是一件好事</p></blockquote><p>小时候，如果我想休息，我会拒绝朋友活动的邀请，因此失去了很多朋友。<br>长大了，如果我想学习，我会拒绝朋友游戏的邀请，因此失去了很多朋友。<br>成年了，一直觉得对朋友不够好，我尝试像宋江那样，接纳更多的人，为朋友做出妥协，结果伤害到了自己。。。<br>回首往事，真想说，命里有时终须有，命里无时莫强求。我本来就是一个赞同物以类聚，人以群分的孩子，虽然失去了朋友的多样性，但是跟朋友们在一起，真的会有一种，相互就是彼此的感觉。</p><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><blockquote><p>无病</p></blockquote><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>还处在一个可以拿健康去换取一些东西的时候。年纪轻轻的不熬夜，等老了怎么办。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><blockquote><p>土皇帝</p></blockquote><h4 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h4><p>今年最远的一次行程应该就是日本了，没有体验到发达国家的繁华，倒是体会到了自己的贫穷，还是喜欢去东南亚当土皇帝的感觉。</p><p>回顾了即将过去的2019年，很多人走到我身边，也有很多离我远去，只是我选择了遗忘，照顾不周，请见谅~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原本打算在2019年写的，一眨眼就从2019年写到了2020年，时间可过得真快~&lt;br&gt;回首过去，已经工作了四个多年头。感叹时间不会因为我而停止的同时，看看我这一年，时间都去哪了~&lt;/p&gt;
&lt;h3 id=&quot;家庭&quot;&gt;&lt;a href=&quot;#家庭&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="脚印" scheme="http://confiwang.github.io/categories/%E8%84%9A%E5%8D%B0/"/>
    
    
      <category term="年终总结" scheme="http://confiwang.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>macOS鼠标事件传递即响应链</title>
    <link href="http://confiwang.github.io/2019/12/03/macOS%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%8D%B3%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>http://confiwang.github.io/2019/12/03/macOS%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%8D%B3%E5%93%8D%E5%BA%94%E9%93%BE/</id>
    <published>2019-12-03T15:21:22.000Z</published>
    <updated>2019-12-12T12:08:08.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HitTest解决的问题"><a href="#HitTest解决的问题" class="headerlink" title="HitTest解决的问题"></a>HitTest解决的问题</h4><ul><li>为什么可见的View接收不到鼠标点击事件？</li><li>如何使得较小的View接收超过View大小的事件？</li><li>如何通过View获取到管理它的ViewController？</li></ul><h4 id="HitTest的表现"><a href="#HitTest的表现" class="headerlink" title="HitTest的表现"></a>HitTest的表现</h4><ul><li><p>下图ViewB是ViewA的子View，并且ViewB的大小小于ViewA。<br><img src="receive.jpg" alt="receive"><br>实验结果：当鼠标左键单击ViewB，ViewB可以正常获取到鼠标事件。</p></li><li><p>下图ViewB是ViewA的子View，但是ViewB的大小大于ViewA，并且ViewA的masksToBounds属性设置为NO;<br><img src="unreceive.jpg" alt="unreceive"><br>实验结果：虽然ViewB是可以正常展示的，但是当鼠标左键单击在ViewB超出部分的时候，ViewB无法获取到鼠标事件。</p></li></ul><h4 id="HitTest的原理"><a href="#HitTest的原理" class="headerlink" title="HitTest的原理"></a>HitTest的原理</h4><blockquote><p>为什么明明点击了子视图，但是却没有响应鼠标事件</p></blockquote><p>我们都知道APPKit基于hitTest:来确定一个事件的响应链，这个确定响应链的操作是自上而下的，当mouseDown位置超出父View的视图边界，hitTest:方法将忽略这个视图和它的所有子视图。所以，即使当视图的masksToBounds属性为NO，子视图超过视图的边界，鼠标真实点击到这个子视图，鼠标事件也不会被响应。  </p><h4 id="HitTest的应用场景"><a href="#HitTest的应用场景" class="headerlink" title="HitTest的应用场景"></a>HitTest的应用场景</h4><ul><li><p>如何使得较小的View接收超过View大小的事件？<br>  可以通过重写hitTest:方法，扩大subview的处理范围实现</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (NSView *)hitTest:(NSPoint)<span class="built_in">point</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NSView *subview in self.subviews) &#123;</span><br><span class="line">        </span><br><span class="line">        CGPoint convertedPoint = [subview convertPoint:<span class="built_in">point</span> fromView:self];</span><br><span class="line">        </span><br><span class="line">        convertedPoint.y+=self.documentVisibleRect.origin.y;</span><br><span class="line"></span><br><span class="line">        NSView *hitTestView = [subview hitTest:convertedPoint];</span><br><span class="line">        <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">            <span class="keyword">return</span> hitTestView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何通过View获取到管理它的ViewController？<br>  通过NSViewController的view属性可以访问到管理的view对象，以及此view的所有subview，但是根据一个view，没有直接的方法可以获取到管理它的NSViewController，这个时候，可以使用responder chain来间接获取。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSResponder *responder = self.nextResponder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    NSLog(@<span class="string">"find nextResponder :%@"</span>, [responder className]);</span><br><span class="line">    <span class="keyword">if</span> ([responder isKindOfClass:[NSViewController class]]) &#123;</span><br><span class="line">        NSLog(@<span class="string">"find %@"</span>, [responder className]);</span><br><span class="line">    &#125;</span><br><span class="line">    responder = responder.nextResponder;</span><br><span class="line">&#125; <span class="keyword">while</span> (responder);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HitTest解决的问题&quot;&gt;&lt;a href=&quot;#HitTest解决的问题&quot; class=&quot;headerlink&quot; title=&quot;HitTest解决的问题&quot;&gt;&lt;/a&gt;HitTest解决的问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;为什么可见的View接收不到鼠标点击事件？&lt;/l
      
    
    </summary>
    
    
      <category term="基础知识" scheme="http://confiwang.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Objective-C" scheme="http://confiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>IPv6概览</title>
    <link href="http://confiwang.github.io/2019/11/16/IPv6%E6%A6%82%E8%A7%88/"/>
    <id>http://confiwang.github.io/2019/11/16/IPv6%E6%A6%82%E8%A7%88/</id>
    <published>2019-11-16T03:04:28.000Z</published>
    <updated>2019-11-16T03:51:17.870Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用IPv6"><a href="#为什么要使用IPv6" class="headerlink" title="为什么要使用IPv6"></a>为什么要使用IPv6</h4><h5 id="IPv4地址极度匮乏"><a href="#IPv4地址极度匮乏" class="headerlink" title="IPv4地址极度匮乏"></a>IPv4地址极度匮乏</h5><p>根据互联网数据研究机构的统计，全世界 76.7亿人口，网民总数已经达到了 43.9 亿（2019年1月）。<br>IPv4的地址池是2^32约42.9亿，IPv4地址极度匮乏</p><h5 id="物联网高速发展"><a href="#物联网高速发展" class="headerlink" title="物联网高速发展"></a>物联网高速发展</h5><p>物联网，现在进入高速发展阶段，地址需求非常大（根据预测，2025年，物联网的连接数将超过270亿），迫切需要IPv6。</p><h5 id="国家发展"><a href="#国家发展" class="headerlink" title="国家发展"></a>国家发展</h5><p>2017年11月中国中共中央办公厅、国务院办公厅印发了《推进互联网协议第六版(IPv6)规模部署行动计划》，提出用 5 到 10 年时间，形成下一代互联网自主技术体系和产业生态，建成全球最大规模的 IPv6 商业应用网络，实现下一代互联网在经济社会各领域深度融合应用，成为全球下一代互联网发展的重要主导力量。</p><h4 id="IPv6全球部署更新概况"><a href="#IPv6全球部署更新概况" class="headerlink" title="IPv6全球部署更新概况"></a>IPv6全球部署更新概况</h4><h5 id="思科统计数据"><a href="#思科统计数据" class="headerlink" title="思科统计数据"></a>思科统计数据</h5><p>思科(Cisco)提供的全球IPv6部署情况统计，是根据各个国家地区的网络（IPv6 Prefix/Transit IPv6 AS），IPv6网站及 IPv6用户等数据，按照一定权值分配计算方法，得出的 IPv6部署程度综合情况。APNIC Labs统计数据，中国排在第66位（该机构的测量工具对中国数据的测量可能不准确）<br><img src="IPv6map.jpg" alt="IPv6map"><br><img src="chinaranking.jpg" alt="chinaranking"><br>根据google网站监测，至2018年12月，使用IPv6访问的用户占总用户最高已超过 26%<br><img src="googlestatistics.jpg" alt="googlestatistics"><br>2012年6月6日，国际互联网协会专门举行了“世界IPv6启动纪念日”。这一天，多家知名网站（如Google、Facebook和Yahoo等）正式开始永久性支持IPv6访问。</p><h5 id="中国网信网统计数据"><a href="#中国网信网统计数据" class="headerlink" title="中国网信网统计数据"></a>中国网信网统计数据</h5><ul><li>中国网信网8月30日发布的第44次《中国互联网络发展状况统计报告》数据显示，截至2019年6月，我国IPv6 地址数量为50286 块/32，较2018年底增长14.3%，已跃居全球第一位。我国IPv6 规模部署不断加速，IPv6 活跃用户数达1. 3亿，基础电信企业已分配IPv6 地址用户数12. 07 亿³;域名总数为 4800 万个，其中“.CN”域名总数为 2185 万个，较2018年底增长2.9%，占我国域名总数的45.5%。</li><li>我国IPv6部署的增长率远高于头部其他国家<br><img src="update.jpg" alt="update"></li><li>今年软件IPv6支持度对比2017年并无太大变化。移动端应用开始发力，三大运营商旗下应用大部分已经支持IPv6，阿里和美团的核心产品也已明确表示支持IPv6，腾讯也随后宣布将在2019年对QQ和微信完成IPv6 升级。</li></ul><h4 id="IPv6的优点"><a href="#IPv6的优点" class="headerlink" title="IPv6的优点"></a>IPv6的优点</h4><p>IPv6的地址池是2^128约340万亿亿亿亿个<br>这是他的地址总数：<br>340282366920938463463374607431768211456</p><h4 id="IPv6地址介绍"><a href="#IPv6地址介绍" class="headerlink" title="IPv6地址介绍"></a>IPv6地址介绍</h4><p>IPv6地址格式<br>xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx<br>X的取值范围0~F</p><h4 id="网络模型简单介绍"><a href="#网络模型简单介绍" class="headerlink" title="网络模型简单介绍"></a>网络模型简单介绍</h4><p>本篇文章主要涉及网络模型中网络层，IP协议<br><img src="networkmodel.jpg" alt="networkmodel"></p><ul><li>网络层任务：将传输层传下来的报文段封装成分组，选择适当的分组使传输层传下来的分组能够交付到目的主机，为每台主机分配IP地址</li><li>网络层功能：为传输层提供服务，组包跟拆包，路由选择，拥塞控制</li><li>网络层协议：ICMP（Internet组管理协议），ARP（Address Resolution Protocol，从IP地址得到MAC地址），RARP（Reverse Address - - - Resolution Protocol），IP，IGMP（Internet互联网控制报文协议）</li><li>网络层传输单位：数据报</li><li>网络层实现硬件：路由器</li></ul><h4 id="IPv6地址展示优化"><a href="#IPv6地址展示优化" class="headerlink" title="IPv6地址展示优化"></a>IPv6地址展示优化</h4><ol><li>IPv6地址：2001:0DB8:02de:0000:0000:0000:0000:0e13</li><li>IPv6省略0地址：2001:DB8:2de:0:0:0:0:e13</li><li>IPv6简写0地址： 2001:DB8:2de::e13（一个IPv6地址中只能存在一个::）</li></ol><h4 id="IPv6分配规则"><a href="#IPv6分配规则" class="headerlink" title="IPv6分配规则"></a>IPv6分配规则</h4><blockquote><p>现在大家都知道了IPv6的地址很多，那么我们怎么去分配他呢？</p></blockquote><ul><li>无状态地址自动配置（SLAAC）<br>  运营商只会给你分配一次前缀地址，当你的路由器获取到前缀地址后，你其它的设备都会通过这个前缀地址向下分配剩余的地址。<br>是不是有点细思极恐，以后IP地址是大家所有设备的唯一标识，并且连接在同一个路由器下的分配的IP将会有相同的前缀，这个可是比身份证号去获取关系链可靠多了。<br>  <img src="IPdispatch.jpg" alt="IPdispatch"></li><li>按照IPv6的分配规则，前缀地址必须在/60位以内。目前中国的运营商有两种前缀，一个是56位，一个是60位。电信大都是56，联通移动大都是60的。当然，这个长度没有好与坏，不管是56还是60，你获得的剩余地址量都是用不完的，哪怕是给你家里每一粒灰尘都分配上公网IP。问题就在于，运营商只会给你分配一次前缀地址，当你的路由器获取到前缀地址后，你其它的设备都会通过这个前缀地址向下分配剩余的地址。<br>打个比方，通过PPPoE拨号，</li></ul><ol><li>你将会获取到WAN口IP地址，这个机制和IPv4是一样的：<br>240e:9c:2a04:c8ad:bdd8:af0b:843b:f60/64</li><li>然后你还可以获取到一个前缀IP地址：<br>240e:9c:2cd3:8d00::1/56</li><li>当你的手机连接WIFI的时候，路由器就会按照这个前缀地址给你的手机向下分配剩余的地址，如：<br>240e:9c:2cd3:8d00:XXXX:XXXX:XXXX:XXXX</li></ol><h4 id="IPv5？"><a href="#IPv5？" class="headerlink" title="IPv5？"></a>IPv5？</h4><p>讲了这么多IPv6跟IPv4，那么有没有IPv5呢？这个各位读者可以自行查询一下</p><h4 id="IPv4-amp-IPv6请求头对比"><a href="#IPv4-amp-IPv6请求头对比" class="headerlink" title="IPv4&amp;IPv6请求头对比"></a>IPv4&amp;IPv6请求头对比</h4><h5 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h5><blockquote><p>根据提供的IP选项，有20-60个字节的可变长度。</p></blockquote><p><img src="IPStruct.jpg" alt="IPStruct"></p><p>下面是一次真实的IPv4请求抓包<br><img src="IPInstant.jpg" alt="IPInstant"><br>0100 …. = Version: 4（ IP协议的版本号，一般有两个值，如果为4就代表是IPv4，6就代表是IPv6协议。 4→IPv4， 6 → IPv6）<br>…. 0101 = Header Length: 20 bytes (5)（IP分组首部长度，这里是以四个字节为单位，如果值为5，则表示首部长度为20个字节（5×4），从图中也可以看到，ip首部长度最短应该是20个字节（一共有五行，每行四个字节），除掉可变部分，固定部分就是20个字节。）<br>Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)（更好地服务不同类型IP数据报(如实时数据报IP电话应用、非实时通信流FTP)，Cisco将TOS前3位标识不同服务等级，即优先级。）<br>Total Length: 430（IP分组的总字节数(首部+数据)，最大IP分组的总长度： 65535B）<br>Time to live: 64（IP分组在网络中可以通过的路由器数（或跳步数））<br>Protocol: TCP (6)（指示IP分组封装的是哪个协议的数据包，6为TCP，表示封装的为TCP段； 17为UDP， 表示封装的是UDP数据报）<br>Source: 10.43.102.78<br>Destination: 101.89.15.106<br>IP源：112.237.231.93，目标：223.202.6.27</p><h5 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h5><blockquote><p>40个字节的固定长度。没有IP报头选项。通常，IPv6报头比 IPv4报头简单。</p></blockquote><p><img src="IPv6Header.jpg" alt="IPv6Header"></p><p>下面是一次真实的IPv6请求抓包<br><img src="IPv6Instant.jpg" alt="IPv6Instant"><br>0110 …. = Version: 6（版本字段用来表示IP数据报使用的是IPv6协议封装）<br>Traffic Class（通信分类字段用来标识对应IPv6的通信流类别，或者说是优先级别，占8位，类似于IPv4中的ToS（服务类型）字段。）<br>Flow Label(流标签字段时IPv6数据报中新增的一个字段，占20位，可用来标记报文的数据流类型，以便在网络层区分不同的报文。)<br>Payload Length: 20（有效载荷长度字段是以字节为单位的标识IPv6数据报中有效载荷部分（包括所有扩展报头部分）的总长度，也就是除了IPv6的基本报头以外的其他部分的总长度，占16位。）<br>Next Header: TCP (6)（下一个头部字段用来标识当前报头（或者扩展报头）的下一个头部类型，占8位。）<br>Hop Limit: 64（跳数限制于IPv4报文中的TTL字段类似，指定了报文可以有效转发的次数，占8位。）<br>Source: 2402:4e00:d000:801:fde0:3fa4:f78e:a3f4<br>Destination: 240e:e1:a900:50::31</p><h4 id="IPv6对比IPv4的区别"><a href="#IPv6对比IPv4的区别" class="headerlink" title="IPv6对比IPv4的区别"></a>IPv6对比IPv4的区别</h4><ul><li><p>首部长度<br>  IPv4首部长度可变，首部的选项字段允许IP首部被扩展，由此导致数据报首部长度可变，故不能预先确定数据字段从何开始，同时也使路由器处理一个IP数据报所需时间差异很大(有的要处理选项，有的不需要)。基于此，IPv6采用固定40字节长度的报头长度(称基本报头)。IPv6如何实现IPv4选项字段类似的功能，答案是扩展报头，并由IPv6基本报头的下一个首部指向扩展报头(如果有的话)。路由器不处理扩展报头，提升了路由器处理效率。</p></li><li><p>分片/重组<br>  网络链路存在MTU (最大传输单元)—链路层数据帧可封装数据的上限。不同链路的MTU不同。<br>  IPv4大MTU分组向较小MTU链路转发时，可以被“分片(fragmented)<br>  <img src="MTU.jpg" alt="MTU"><br>  IPv6，分片与重组只能在源与目的地上执行，不允许在中间路由器进行。分片与重组是个耗时的操作，将该功能从路由器转移到端系统，大大加快了网络中的IP转发速率。那，如果路由器收到IPv6数据报太大而不能转发到出链路上怎么办？该路由器丢弃该包，并向发送发发回一个”分组太大”的ICMP差错报文，于是发送发使用较小长度的IP数据报重发数据。</p></li><li><p>首部检查和<br>  每个路由器上，IPv4首部检查和都需要重新计算，是一项耗时操作。加之，传输层和链接层协议执行了检验操作，网络传输可靠性提升，所以IPv6不进行首部检查和，从而更快速处理IP分组。</p></li></ul><h4 id="IPv6地址切换流程"><a href="#IPv6地址切换流程" class="headerlink" title="IPv6地址切换流程"></a>IPv6地址切换流程</h4><h5 id="双栈技术"><a href="#双栈技术" class="headerlink" title="双栈技术"></a>双栈技术</h5><p>广域网上的2个节点间往往经过多个路由器，按照双栈技术的部署要求，之间的所有节点都要支持IPv4/IPv6双栈，并且都要配置了IPv4的公网IP才能正常工作，这里就无法解决IPv4公网地址匮乏的问题。所以一般不单独使用。<br><img src="IPv6both.jpg" alt="IPv6both"><br>我们的目标是要废弃掉IPv4，像下图这样<br><img src="IPv6Only.jpg" alt="IPv6Only"></p><h5 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h5><p>当前的网络是以IPv4为主，因此尽可能地充分利用IPv4网络进行IPv6通信是十分好的手段之一。隧道技术就是这样子的一种过渡技术。<br>隧道将IPv6的数据报文封装在IPv4的报文头部后面（IPv6的数据报文是IPv4的载荷部分），IPv6通信节点之间传输的IPv6数据包就可以穿越IPv4网络进行传输。隧道技术的一个很重要的优点是透明性，通过隧道进行通信的两个IPv6节点（或者节点上的应用程序）几乎感觉不到隧道的存在。<br><img src="tunnel.jpg" alt="tunnel"><br>上图是一种典型的隧道技术：路由器-路由器隧道，两个IPv6网络中的主机通过隧道方式穿越了IPv4进行通信。其中C节点和D节点被称为边界路由器，边界路由器必须要支持IPv4-IPv6双栈。当IPv6网络1的主机A将IPv6数据包发给边界路由器C，C对IPv6数据包进行IPv4封装，然后在IPv4网络上进行传输，发送到边界路由器D，D收到IPv4的数据包后剥掉IPv4的包头，还原IPv6的数据包，发送到IPv6网络2的主机B。</p><h5 id="转换技术"><a href="#转换技术" class="headerlink" title="转换技术"></a>转换技术</h5><p>NAT64/DNS64<br><img src="net64dns64.jpg" alt="net64dns64"><br>DNS64在RFC6147中明确定义，将IPv6的地址记录AAAA DNS查询消息转换为IPv4的地址记录查询。当IPv6节点发起DNS请求，NAT64/DNS64中间层同时发起A域名查询和AAAA域名查询。如果仅有A域名查询的IPv4地址响应，表明IPv6节点需要访问一个IPv4的节点，NAT64/DNS64中间层将回应的IPv4地址转换为IPv6地址，返回给IPv6节点。<br><img src="net64dns64route.jpg" alt="net64dns64route"></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://blog.csdn.net/frank_jb/article/details/45093615" target="_blank" rel="noopener">IPv4与IPv6数据包格式</a><br><a href="https://zhuanlan.zhihu.com/p/36542469" target="_blank" rel="noopener">IPv6，到底是什么？</a><br><a href="https://zhuanlan.zhihu.com/p/35509560" target="_blank" rel="noopener">IPv6原理、应用与实践</a><br><a href="https://zhuanlan.zhihu.com/p/35509560" target="_blank" rel="noopener">IPv6 地址规划与分配——全球可路由地址</a><br><a href="http://www.cac.gov.cn/2019-08/30/c_1124939619.htm" target="_blank" rel="noopener">IPv6 地址数量全球第一 ，“.CN域名数量持续增长</a><br><a href="https://ccie.lol/knowledge-base/rfc-1883-cn-internet-protocol-version-6-ipv6-specification/" target="_blank" rel="noopener">【RFC文档】RFC 1883 中文 – Internet协议，版本6（IPv6）说明书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要使用IPv6&quot;&gt;&lt;a href=&quot;#为什么要使用IPv6&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用IPv6&quot;&gt;&lt;/a&gt;为什么要使用IPv6&lt;/h4&gt;&lt;h5 id=&quot;IPv4地址极度匮乏&quot;&gt;&lt;a href=&quot;#IPv4地址极度匮乏&quot;
      
    
    </summary>
    
    
      <category term="网络" scheme="http://confiwang.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IPv6" scheme="http://confiwang.github.io/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>设计模式开篇</title>
    <link href="http://confiwang.github.io/2019/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87/"/>
    <id>http://confiwang.github.io/2019/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87/</id>
    <published>2019-11-12T01:51:13.000Z</published>
    <updated>2019-11-12T01:59:08.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本文的东西会让大家感到有点抽象，好似空中楼阁，看上去只是在讲一些，大家都知道的，绝对正确的废话。不过我也是初入设计模式，对下面的内容产生了一些共鸣，因此记录下来，希望在工作中可以实际使用到这些基本原则。找到更加切实的案例跟大家分享。</p></blockquote><h3 id="设计模式基本原则"><a href="#设计模式基本原则" class="headerlink" title="设计模式基本原则"></a>设计模式基本原则</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><blockquote><p>就一个类而言，应该仅有一个引起它变化的原因。</p></blockquote><ul><li>怎么去理解这句话，就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多余一个的职责。</li></ul><h4 id="开放-封闭原则（面向对象设计中最核心的原则）"><a href="#开放-封闭原则（面向对象设计中最核心的原则）" class="headerlink" title="开放-封闭原则（面向对象设计中最核心的原则）"></a>开放-封闭原则（面向对象设计中最核心的原则）</h4><blockquote><p>对于扩展是开放的，对于更改是封闭的。</p></blockquote><ul><li>当需求变更的时候，创建抽象来隔离以后发生的同类变化。</li><li>比如在工厂模式的例子中，使用继承，多态来隔离具体加法，减法跟client的耦合，使用反射来避免对switch类的改动，可以直接在配置文件中增加switch-case。</li></ul><h4 id="合成-聚合服用原则"><a href="#合成-聚合服用原则" class="headerlink" title="合成/聚合服用原则"></a>合成/聚合服用原则</h4><blockquote><p>尽量使用合成/聚合，尽量不要使用类继承。</p></blockquote><ul><li>继承在某种程度上破坏了封装性，父类实现细节暴露给了子类，子类父类耦合度高。</li><li>需要多角度去分类实现对象时，只用继承会造成大量的类增加。</li></ul><h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><blockquote><p>A、高层模块不应该依赖底层模块。两个都应该依赖抽象。<br>  B、抽象不应该依赖细节。细节应该依赖抽象。</p></blockquote><ul><li>说白了，就是要针对接口编程，不要对实现编程。</li><li>比如我们做的大多数项目需要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时，高层模块就去调用这些函数，导致高层模块跟底层模块绑定在一起，当想更换数据库的时候，高层模块也需要重写，也就是高层模块跟底层模块耦合在一起，都无法被复用。</li></ul><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h4><blockquote><p>子类必须能够替换掉他们的父类类型。</p></blockquote><ul><li>只有当子类可以替换掉父类，软件单位的功能不受影响是，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</li><li>主张面向接口编程，在不更改父类的情况下，实现父类的抽象方法，接口。在父类的每个抽象方法中，应该细分其中的各个部分，只保留子类之间的差异部分。相同部分转移到父类中实现，减少重复代码 。</li><li>依赖倒转原则是面向对象设计的标志，如果编写时考虑的都如何针对抽象编程而不是针对细节编程，即程序中所以的依赖关系都是终止于抽象类或者接口，那就是面向对象的涉及，反之那就是过程化的设计了。</li></ul><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><blockquote><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p></blockquote><ul><li>最少知道原则。</li><li>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</li></ul><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><ul><li>封装</li><li>继承</li><li>多态<ul><li>子类使用override关键字，将父类实现替换为自己的实现。</li></ul></li></ul><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li>《大话设计模式》-程杰</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文的东西会让大家感到有点抽象，好似空中楼阁，看上去只是在讲一些，大家都知道的，绝对正确的废话。不过我也是初入设计
      
    
    </summary>
    
    
      <category term="软件架构" scheme="http://confiwang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="设计模式" scheme="http://confiwang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>详解macOS多线程和锁</title>
    <link href="http://confiwang.github.io/2019/10/11/%E8%AF%A6%E8%A7%A3macOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/"/>
    <id>http://confiwang.github.io/2019/10/11/%E8%AF%A6%E8%A7%A3macOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/</id>
    <published>2019-10-11T14:24:46.000Z</published>
    <updated>2019-10-12T01:22:24.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的状态与生命周期"><a href="#线程的状态与生命周期" class="headerlink" title="线程的状态与生命周期"></a>线程的状态与生命周期</h3><blockquote><p>下图是线程状态示意图，从图中可以看出线程的生命周期是：新建 - 就绪 - 运行 - 阻塞 - 死亡  </p></blockquote><p><img src="thread.jpg" alt="thread"></p><ul><li>下面分别阐述线程生命周期中的每一步<ul><li>新建：实例化线程对象</li><li>就绪：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。</li><li>运行：CPU 负责调度可调度线程池中线程的执行。线程执行完成之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。</li><li>阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate（休眠到指定日期），@synchronized（互斥锁）。</li><li>死亡：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中止执行/在主线程中止线程对象</li><li>还有线程的exit和cancel<ul><li>[NSThread exit]：一旦强行终止线程，后续的所有代码都不会被执行。</li><li>[thread cancel]取消：并不会直接取消线程，只是给线程对象添加 isCancelled 标记。</li></ul></li></ul></li></ul><h3 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h3><h4 id="NSThread的创建"><a href="#NSThread的创建" class="headerlink" title="NSThread的创建"></a>NSThread的创建</h4><blockquote><p>NSThread有三种创建方式</p></blockquote><ul><li>init方式</li><li>detachNewThreadSelector创建好之后自动启动</li><li>performSelectorInBackground创建好之后也是直接启动  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法一，需要start */</span></span><br><span class="line">NSThread -thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething1:) object:@<span class="string">"NSThread1"</span>];</span><br><span class="line"><span class="comment">// 线程加入线程池等待CPU调度，时间很快，几乎是立刻执行</span></span><br><span class="line">[thread1 start];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法二，创建好之后自动启动 */</span></span><br><span class="line">[NSThread detachNewThreadSelector:@selector(doSomething2:) toTarget:self withObject:@<span class="string">"NSThread2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法三，隐式创建，直接启动 */</span></span><br><span class="line">[self performSelectorInBackground:@selector(doSomething3:) withObject:@<span class="string">"NSThread3"</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething1:(NSObject -)object &#123;</span><br><span class="line">    <span class="comment">// 传递过来的参数</span></span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,object);</span><br><span class="line">    NSLog(@<span class="string">"doSomething1：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething2:(NSObject -)object &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,object);</span><br><span class="line">    NSLog(@<span class="string">"doSomething2：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething3:(NSObject -)object &#123;</span><br><span class="line">    NSLog(@<span class="string">"%@"</span>,object);</span><br><span class="line">    NSLog(@<span class="string">"doSomething3：%@"</span>,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h4><blockquote><p>GCD自动管理线程的生命周期（创建线程，调度任务，销毁线程等）</p></blockquote><ul><li><p>dispatch_get_global_queue参数详解<br>  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)//flags保留参数，不要填0以外的其他数字</p></li><li><p>dispatch_barrier_async栅栏，无所队列实现，将栅栏前后的任务分成前后两组，第一组执行完之后，才执行第二组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)barrierGCD:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">// 并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">// 异步执行</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSLog(@&quot;栅栏：并发异步1   %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSLog(@&quot;栅栏：并发异步2   %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;------------barrier------------%@&quot;, [NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;------- 并发异步执行，但是34一定在12后面 ---------&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSLog(@&quot;栅栏：并发异步3   %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSLog(@&quot;栅栏：并发异步4   %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果输出  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">栅栏：并发异步1   &#123;number = 3, name = (null)&#125;</span><br><span class="line">栅栏：并发异步2   &#123;number = 6, name = (null)&#125;</span><br><span class="line">栅栏：并发异步1   &#123;number = 3, name = (null)&#125;</span><br><span class="line">栅栏：并发异步2   &#123;number = 6, name = (null)&#125;</span><br><span class="line">栅栏：并发异步1   &#123;number = 3, name = (null)&#125;</span><br><span class="line">栅栏：并发异步2   &#123;number = 6, name = (null)&#125;</span><br><span class="line"> ------------barrier------------&#123;number = 6, name = (null)&#125;</span><br><span class="line">------- 并发异步执行，但是34一定在12后面 ---------</span><br><span class="line">栅栏：并发异步4   &#123;number = 3, name = (null)&#125;</span><br><span class="line">栅栏：并发异步3   &#123;number = 6, name = (null)&#125;</span><br><span class="line">栅栏：并发异步4   &#123;number = 3, name = (null)&#125;</span><br><span class="line">栅栏：并发异步3   &#123;number = 6, name = (null)&#125;</span><br><span class="line">栅栏：并发异步4   &#123;number = 3, name = (null)&#125;</span><br><span class="line">栅栏：并发异步3   &#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>GCD队列组实现<br>  在所有队列执行完毕之后得到通知</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testGroup &#123;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> group =  dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"队列组：有一个耗时操作完成！"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"队列组：有一个耗时操作完成！"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"队列组：前面的耗时操作都完成了，回到主线程进行相关操作"</span>);</span><br><span class="line">    &#125;);<span class="comment">//非阻塞等待所有队列执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dispatch_once_t实现单例</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSObject *instance = nil;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"程序运行过程中我只执行了一次！"</span>);</span><br><span class="line">    instance = [[NSObject alloc] init];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>GCD延时执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 - NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 5秒后异步执行</span><br><span class="line">    NSLog(@&quot;我已经等待了5秒！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="NSOperation的使用"><a href="#NSOperation的使用" class="headerlink" title="NSOperation的使用"></a>NSOperation的使用</h4><blockquote><p>基于GCD的更高一层的封装</p></blockquote><ul><li><p>NSOperation的三种创建方式</p><ul><li><p>使用NSInvocationOperation创建<br>程序在主线程执行，没有开启新线程。这是因为NSOperation多线程的使用需要配合队列NSOperationQueue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testNSInvocationOperation &#123;</span><br><span class="line">    <span class="comment">// 创建NSInvocationOperation</span></span><br><span class="line">    NSInvocationOperation -invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperation) object:nil];</span><br><span class="line">    <span class="comment">// 开始执行操作</span></span><br><span class="line">    [invocationOperation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invocationOperation &#123;</span><br><span class="line">    NSLog(@<span class="string">"NSInvocationOperation包含的任务，没有加入队列========%@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用NSBlockOperation创建<br>程序在主线程执行，没有开启新线程。这是因为NSOperation多线程的使用需要配合队列NSOperationQueue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testNSBlockOperation &#123;</span><br><span class="line">    <span class="comment">// 把任务放到block中</span></span><br><span class="line">    NSBlockOperation -blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@<span class="string">"NSBlockOperation包含的任务，没有加入队列========%@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [blockOperation start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用继承自NSOperation的子类创建<br>定义一个继承自NSOperation的类，然后重写它的main方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/-------------------&quot;WHOperation.h&quot;-------------------------/</span><br><span class="line"></span><br><span class="line">#import @interface WHOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/-------------------&quot;WHOperation.m&quot;-------------------------/</span><br><span class="line"></span><br><span class="line">#import &quot;WHOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation WHOperation</span><br><span class="line"></span><br><span class="line">- (void)main &#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSLog(@&quot;NSOperation的子类WHOperation======%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/-----------------回到主控制器使用WHOperation----------------------/</span><br><span class="line"></span><br><span class="line">- (void)testWHOperation &#123;</span><br><span class="line">    WHOperation -operation = [[WHOperation alloc] init];</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NSOperation+NSOperationQueue，将任务加入队列执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)testOperationQueue &#123;</span><br><span class="line">    // 创建队列，默认并发</span><br><span class="line">    NSOperationQueue -queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 创建操作，NSInvocationOperation</span><br><span class="line">    NSInvocationOperation -invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperationAddOperation) object:nil];</span><br><span class="line">    // 创建操作，NSBlockOperation</span><br><span class="line">    NSBlockOperation -blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSLog(@&quot;addOperation把任务添加到队列======%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [queue addOperation:invocationOperation];</span><br><span class="line">    [queue addOperation:blockOperation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)invocationOperationAddOperation &#123;</span><br><span class="line">    NSLog(@&quot;invocationOperation===aaddOperation把任务添加到队列====%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>setSuspended/cancel/cancelAllOperations<br>  暂停和取消不是立刻取消当前操作，而是等当前的操作执行完之后不再进行新的操作。</p></li><li><p>操作依赖，当OperationA结束的时候，才开始执行OperationB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)testAddDependency &#123;</span><br><span class="line"></span><br><span class="line">    // 并发队列</span><br><span class="line">    NSOperationQueue -queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 操作1</span><br><span class="line">    NSBlockOperation -operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSLog(@&quot;operation1======%@&quot;, [NSThread  currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 操作2</span><br><span class="line">    NSBlockOperation -operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;----operation2依赖于operation1，只有当operation1执行完毕，operation2才会执行----&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSLog(@&quot;operation2======%@&quot;, [NSThread  currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 使操作2依赖于操作1</span><br><span class="line">    [operation2 addDependency:operation1];</span><br><span class="line">    // 把操作加入队列</span><br><span class="line">    [queue addOperation:operation1];</span><br><span class="line">    [queue addOperation:operation2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="锁概念介绍"><a href="#锁概念介绍" class="headerlink" title="锁概念介绍"></a>锁概念介绍</h3><blockquote><p>锁用于解决线程争夺资源的问题，一般分为两种，自旋锁(spin)和互斥锁(mutex)。  </p></blockquote><ul><li><p>互斥锁可以解释为线程获取锁，发现锁被占用，就向系统申请锁空闲时唤醒他并立刻休眠。  </p></li><li><p>自旋锁比较简单，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。  </p><ul><li><p>自旋锁应用场景<br>OC中实例变量的set/get，原子操作的颗粒度最小，只限于读写，对于性能的要求很高，如果使用了互斥锁势必在切换线程上耗费大量资源。相比之下，由于读写操作耗时比较小，能够在一个时间片内完成，自旋更适合这个场景。 </p></li><li><p>自旋锁的坑<br>新版iOS中，系统维护了5个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，导致低优先级线程迟迟不能处理资源并释放锁，导致陷入死锁，从而破坏了spin lock。</p></li><li><p>下面是苹果spinlock_t实现，系统中自旋锁已经全部改为互斥锁（os_unfair_lock）实现了，只是名称一直没有更改，坑货。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">spinlock_t</span> = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">mutex_t</span> = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">monitor_t</span> = monitor_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">recursive_mutex_t</span> = recursive_mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use fork_unsafe_lock to get a lock that isn't </span></span><br><span class="line"><span class="comment">// acquired and released around fork().</span></span><br><span class="line"><span class="comment">// All fork-safe locks are checked in debug builds.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fork_unsafe_lock_t</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">fork_unsafe_lock_t</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">fork_unsafe_lock_t</span> fork_unsafe_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"objc-lockdebug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> Debug&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mutex_tt</span> :</span> <span class="keyword">nocopy_t</span> &#123;</span><br><span class="line">    os_unfair_lock mLock;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">mutex_tt</span><span class="params">()</span> : <span class="title">mLock</span><span class="params">(OS_UNFAIR_LOCK_INIT)</span> </span>&#123;</span><br><span class="line">        lockdebug_remember_mutex(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">mutex_tt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">fork_unsafe_lock_t</span> unsafe)</span> : <span class="title">mLock</span><span class="params">(OS_UNFAIR_LOCK_INIT)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lockdebug_mutex_lock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        os_unfair_lock_lock_with_options_inline</span><br><span class="line">            (&amp;mLock, OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lockdebug_mutex_unlock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        os_unfair_lock_unlock_inline(&amp;mLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="MacOS开发中用到的锁"><a href="#MacOS开发中用到的锁" class="headerlink" title="MacOS开发中用到的锁"></a>MacOS开发中用到的锁</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><h5 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h5><blockquote><p>只对属性的set/get方法加锁</p></blockquote><ul><li>reallySetProperty方法实现<br>  从源码可以看到，atomic实现是spinlock_t，而spinlock_t从上文看到内部实现是互斥锁  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id -slot = (id-) ((<span class="keyword">char</span>-)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (-slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = -slot;</span><br><span class="line">        -slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = -slot;</span><br><span class="line">        -slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><blockquote><p>对代码块加锁</p></blockquote><ul><li><p>锁实现代码<br>  从源码可以看到，传入nil，不会上锁，会以传入的obj的地址为key，绑定一个互斥锁，当obj改变时，互斥锁失效</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData- data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@synchronized(self)的坑<br>  加锁对象对外可见（self），被外部使用@synchronized (objectA)导致死锁，正确的做法是传入一个类内部维护的NSObject对象，而且这个对象是对外不可见的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class A</span></span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">    [_sharedLock lock];</span><br><span class="line">    NSLog(@<span class="string">"code in class A"</span>);</span><br><span class="line">    [_sharedLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B</span></span><br><span class="line">[_sharedLock lock];</span><br><span class="line">@synchronized (objectA) &#123;</span><br><span class="line">    NSLog(@<span class="string">"code in class B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">[_sharedLock unlock];</span><br></pre></td></tr></table></figure></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote><p>互斥量值只能为0/1，信号量值可以为非负整数。<br>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到</p></blockquote><ul><li>信号量使用代码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> workConcurrentQueue = dispatch_queue_create(<span class="string">"cccccccc"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"sssssssss"</span>,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  dispatch_async(serialQueue, ^&#123;</span><br><span class="line">      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">      dispatch_async(workConcurrentQueue, ^&#123;</span><br><span class="line">          NSLog(@<span class="string">"thread-info:%@开始执行任务%d"</span>,[NSThread currentThread],(<span class="keyword">int</span>)i);</span><br><span class="line">          sleep(<span class="number">1</span>);</span><br><span class="line">          NSLog(@<span class="string">"thread-info:%@结束执行任务%d"</span>,[NSThread currentThread],(<span class="keyword">int</span>)i);</span><br><span class="line">          dispatch_semaphore_signal(semaphore);&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"主线程...!"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://vanchchen.github.io/p/168d.html" target="_blank" rel="noopener">Atomic原子操作原理剖析</a></li><li><a href="http://www.cocoachina.com/articles/19769" target="_blank" rel="noopener">iOS多线程全套：线程生命周期，多线程的四种解决方案，线程安全问题，GCD的使用，NSOperation的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程的状态与生命周期&quot;&gt;&lt;a href=&quot;#线程的状态与生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的状态与生命周期&quot;&gt;&lt;/a&gt;线程的状态与生命周期&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;下图是线程状态示意图，从图中可以看出线程的生命周期
      
    
    </summary>
    
    
      <category term="基础知识" scheme="http://confiwang.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Objective-C" scheme="http://confiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>深入Objective-C：方法调用</title>
    <link href="http://confiwang.github.io/2019/09/22/%E6%B7%B1%E5%85%A5Objective-C%EF%BC%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://confiwang.github.io/2019/09/22/%E6%B7%B1%E5%85%A5Objective-C%EF%BC%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</id>
    <published>2019-09-22T01:52:36.000Z</published>
    <updated>2019-10-11T14:29:30.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看汇编代码执行"><a href="#查看汇编代码执行" class="headerlink" title="查看汇编代码执行"></a>查看汇编代码执行</h2><blockquote><p>正常断点到我们的自定义调用再点击下一步这个方法调用流程就结束了，那么能不能再看到多一点内容？ </p></blockquote><ul><li><p>我们可以在菜单中选择，查看汇编代码<br>  <img src="assembly.jpg" alt="assembly"></p></li><li><p>在汇编模式下设置断点<br>  <img src="breakpoint.jpg" alt="breakpoint"></p></li><li><p>在汇编模式下按住Ctrl调试，按指令单步执行<br>  Step into Instruction(hold control)<br>  <img src="stepinto.jpg" alt="stepinto"></p></li><li><p>单步执行指令进入objc_msgSend，找到其所在的库，接下来就是找到生成这个库的代码<br>  <img src="libObjc.jpg" alt="libObjc"></p></li></ul><h2 id="运行Runtime代码"><a href="#运行Runtime代码" class="headerlink" title="运行Runtime代码"></a>运行Runtime代码</h2><blockquote><p>虽然苹果很。。。但是苹果爸爸其实也有开源部分代码，恰好有我们需要的 </p></blockquote><ul><li><p>在苹果开源的代码中进行搜索objc4<br>我下载的版本是objc4-756.2<br>  <a href="https://opensource.apple.com" target="_blank" rel="noopener">开源代码地址</a><br>  <a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">源码下载地址</a></p></li><li><p>编译后发现很多错误，可以参照以下博客解决<br>遇见的错误剧本都能在这篇文章找到，当然也可以跟着一步一步做，不过我没试过~<br><a href="http://www.cocoachina.com/cms/wap.php?action=article&id=26754" target="_blank" rel="noopener">Runtime源码编译</a></p></li></ul><h2 id="消息发送Runtime入口"><a href="#消息发送Runtime入口" class="headerlink" title="消息发送Runtime入口"></a>消息发送Runtime入口</h2><blockquote><p>准备工作结束，可以进入正题了  </p></blockquote><ul><li><p>搜索方法入口entry _objc_msgSend<br>  <img src="entry.jpg" alt="entry"></p></li><li><p>找到以自己处理器架构结尾的文件，找到_objc_msgSend函数实现</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ENTRY _objc_msgSend</span><br><span class="line">  UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">  NilTestNORMAL</span><br><span class="line"></span><br><span class="line">  GetIsaFast NORMAL<span class="comment">// r10 = self-&gt;isa</span></span><br><span class="line">  CacheLookup NORMAL, CALL<span class="comment">// calls IMP on success</span></span><br><span class="line"></span><br><span class="line">  NilTestReturnZero NORMAL</span><br><span class="line"></span><br><span class="line">  GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache miss: go search the method lists</span></span><br><span class="line">LCacheMiss:</span><br><span class="line">  <span class="comment">// isa still in r10</span></span><br><span class="line">  jmp__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">  END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h2><blockquote><p>解析上一节找到的函数实现  </p></blockquote><h3 id="CacheLookup，IMP查找先走缓存"><a href="#CacheLookup，IMP查找先走缓存" class="headerlink" title="CacheLookup，IMP查找先走缓存"></a>CacheLookup，IMP查找先走缓存</h3><ul><li><p>.macro    CacheLookup找到宏定义，注释中可以看到部分汇编代码对应的指令 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// CacheLookupreturn-type, caller</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Locate the implementation for a class in a selector's method cache.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Takes: </span></span><br><span class="line"><span class="comment">//  $0 = NORMAL, FPRET, FP2RET, STRET</span></span><br><span class="line"><span class="comment">//  $1 = CALL, LOOKUP, GETIMP</span></span><br><span class="line"><span class="comment">//  a1 or a2 (STRET) = receiver</span></span><br><span class="line"><span class="comment">//  a2 or a3 (STRET) = selector</span></span><br><span class="line"><span class="comment">//  r10 = class to search</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// On exit: r10 clobbered</span></span><br><span class="line"><span class="comment">//    (found) calls or returns IMP in r11, eq/ne set for forwarding</span></span><br><span class="line"><span class="comment">//    (not found) jumps to LCacheMiss, class still in r10</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure></li><li><p>CacheLookup方法实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">.macroCacheLookup</span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> != STRET</span><br><span class="line">  movq%a2, %r11<span class="comment">// r11 = _cmd</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">  movq%a3, %r11<span class="comment">// r11 = _cmd</span></span><br><span class="line">.endif</span><br><span class="line">  andl<span class="number">24</span>(%r10), %r11d<span class="comment">// r11 = _cmd &amp; class-&gt;cache.mask</span></span><br><span class="line">  shlq$$<span class="number">4</span>, %r11<span class="comment">// r11 = offset = (_cmd &amp; mask)&lt;&lt;4</span></span><br><span class="line">  addq<span class="number">16</span>(%r10), %r11<span class="comment">// r11 = class-&gt;cache.buckets + offset</span></span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> != STRET</span><br><span class="line">  cmpqcached_sel(%r11), %a2<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">  cmpqcached_sel(%r11), %a3<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">.endif</span><br><span class="line">  jne <span class="number">1f</span><span class="comment">//     scan more</span></span><br><span class="line">  <span class="comment">// CacheHit must always be preceded by a not-taken `jne` instruction</span></span><br><span class="line">  CacheHit $<span class="number">0</span>, $<span class="number">1</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">  <span class="comment">// loop</span></span><br><span class="line">  cmpq$$<span class="number">1</span>, cached_sel(%r11)</span><br><span class="line">  jbe<span class="number">3f</span><span class="comment">// if (bucket-&gt;sel &lt;= 1) wrap or miss</span></span><br><span class="line"></span><br><span class="line">  addq$$<span class="number">16</span>, %r11<span class="comment">// bucket++</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> != STRET</span><br><span class="line">  cmpqcached_sel(%r11), %a2<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">  cmpqcached_sel(%r11), %a3<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">.endif</span><br><span class="line">  jne <span class="number">1b</span><span class="comment">//     scan more</span></span><br><span class="line">  <span class="comment">// CacheHit must always be preceded by a not-taken `jne` instruction</span></span><br><span class="line">  CacheHit $<span class="number">0</span>, $<span class="number">1</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">  <span class="comment">// wrap or miss</span></span><br><span class="line">  jbLCacheMiss_f<span class="comment">// if (bucket-&gt;sel &lt; 1) cache miss</span></span><br><span class="line">  <span class="comment">// wrap</span></span><br><span class="line">  movqcached_imp(%r11), %r11<span class="comment">// bucket-&gt;imp is really first bucket</span></span><br><span class="line">  jmp <span class="number">2f</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line">  <span class="comment">// The slow path may detect any corruption and halt later.</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">  <span class="comment">// loop</span></span><br><span class="line">  cmpq$$<span class="number">1</span>, cached_sel(%r11)</span><br><span class="line">  jbe<span class="number">3f</span><span class="comment">// if (bucket-&gt;sel &lt;= 1) wrap or miss</span></span><br><span class="line"></span><br><span class="line">  addq$$<span class="number">16</span>, %r11<span class="comment">// bucket++</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> != STRET</span><br><span class="line">  cmpqcached_sel(%r11), %a2<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">  cmpqcached_sel(%r11), %a3<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">.endif</span><br><span class="line">  jne <span class="number">1b</span><span class="comment">//     scan more</span></span><br><span class="line">  <span class="comment">// CacheHit must always be preceded by a not-taken `jne` instruction</span></span><br><span class="line">  CacheHit $<span class="number">0</span>, $<span class="number">1</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">  <span class="comment">// double wrap or miss</span></span><br><span class="line">  jmpLCacheMiss_f</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure></li></ul><h3 id="LCacheMiss"><a href="#LCacheMiss" class="headerlink" title="LCacheMiss"></a>LCacheMiss</h3><ul><li>缓存不存在时的处理，跳转位置可以在刚才_objc_msgSend方法找到<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LCacheMiss:</span><br><span class="line"><span class="comment">// isa still in r10</span></span><br><span class="line">jmp__objc_msgSend_uncached</span><br></pre></td></tr></table></figure></li></ul><h3 id="objc-msgSend-uncached"><a href="#objc-msgSend-uncached" class="headerlink" title="__objc_msgSend_uncached"></a>__objc_msgSend_uncached</h3><ul><li>__objc_msgSend_uncached实现  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line"><span class="comment">// Out-of-band r10 is the searched class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// r10 is already the class to search</span></span><br><span class="line">MethodTableLookup NORMAL<span class="comment">// r11 = IMP</span></span><br><span class="line">jmp*%r11<span class="comment">// goto *imp</span></span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure></li></ul><h3 id="MethodTableLookup，查找类-原类的方法列表"><a href="#MethodTableLookup，查找类-原类的方法列表" class="headerlink" title="MethodTableLookup，查找类/原类的方法列表"></a>MethodTableLookup，查找类/原类的方法列表</h3><ul><li>MethodTableLookup实现   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line"></span><br><span class="line">  push%rbp</span><br><span class="line">  mov%rsp, %rbp</span><br><span class="line">  </span><br><span class="line">  sub$$<span class="number">0x80</span>+<span class="number">8</span>, %rsp<span class="comment">// +8 for alignment</span></span><br><span class="line"></span><br><span class="line">  movdqa%xmm0, <span class="number">-0x80</span>(%rbp)</span><br><span class="line">  push%rax<span class="comment">// might be xmm parameter count</span></span><br><span class="line">  movdqa%xmm1, <span class="number">-0x70</span>(%rbp)</span><br><span class="line">  push%a1</span><br><span class="line">  movdqa%xmm2, <span class="number">-0x60</span>(%rbp)</span><br><span class="line">  push%a2</span><br><span class="line">  movdqa%xmm3, <span class="number">-0x50</span>(%rbp)</span><br><span class="line">  push%a3</span><br><span class="line">  movdqa%xmm4, <span class="number">-0x40</span>(%rbp)</span><br><span class="line">  push%a4</span><br><span class="line">  movdqa%xmm5, <span class="number">-0x30</span>(%rbp)</span><br><span class="line">  push%a5</span><br><span class="line">  movdqa%xmm6, <span class="number">-0x20</span>(%rbp)</span><br><span class="line">  push%a6</span><br><span class="line">  movdqa%xmm7, <span class="number">-0x10</span>(%rbp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _class_lookupMethodAndLoadCache3(receiver, selector, class)</span></span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> == NORMAL</span><br><span class="line">  <span class="comment">// receiver already in a1</span></span><br><span class="line">  <span class="comment">// selector already in a2</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">  movq%a2, %a1</span><br><span class="line">  movq%a3, %a2</span><br><span class="line">.endif</span><br><span class="line">  movq%r10, %a3</span><br><span class="line">  call__class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IMP is now in %rax</span></span><br><span class="line">  movq%rax, %r11</span><br><span class="line"></span><br><span class="line">  movdqa<span class="number">-0x80</span>(%rbp), %xmm0</span><br><span class="line">  pop%a6</span><br><span class="line">  movdqa<span class="number">-0x70</span>(%rbp), %xmm1</span><br><span class="line">  pop%a5</span><br><span class="line">  movdqa<span class="number">-0x60</span>(%rbp), %xmm2</span><br><span class="line">  pop%a4</span><br><span class="line">  movdqa<span class="number">-0x50</span>(%rbp), %xmm3</span><br><span class="line">  pop%a3</span><br><span class="line">  movdqa<span class="number">-0x40</span>(%rbp), %xmm4</span><br><span class="line">  pop%a2</span><br><span class="line">  movdqa<span class="number">-0x30</span>(%rbp), %xmm5</span><br><span class="line">  pop%a1</span><br><span class="line">  movdqa<span class="number">-0x20</span>(%rbp), %xmm6</span><br><span class="line">  pop%rax</span><br><span class="line">  movdqa<span class="number">-0x10</span>(%rbp), %xmm7</span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> == NORMAL</span><br><span class="line">  cmp%r11, %r11<span class="comment">// set eq for nonstret forwarding</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">  test%r11, %r11<span class="comment">// set ne for stret forwarding</span></span><br><span class="line">.endif</span><br><span class="line">  </span><br><span class="line">  leave</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure></li></ul><h3 id="class-lookupMethodAndLoadCache3"><a href="#class-lookupMethodAndLoadCache3" class="headerlink" title="__class_lookupMethodAndLoadCache3"></a>__class_lookupMethodAndLoadCache3</h3><ul><li><p>__class_lookupMethodAndLoadCache3全局搜索不存在<br><img src="lookupMethod.jpg" alt="lookupMethod">  </p></li><li><p>因为Runtime是C/C++/汇编完成的，怀疑汇编代码调用的C/C++方法，去掉一个下划线搜索，找到熟悉的C++方法，可以愉快的使用jump to definition跳转查看源码了，并且又可以使用断点进行调试了，当然了，添加断点首先有一个可执行文件</p></li><li><p>添加主函数入口，愉快的debug<br>我们发现runtime只是一个动态链接库，我们再创建一个target，选择Command Line Tool，在新建的Target中引用runtime库（libobjc.A.dylib）<br><img src="target.jpg" alt="target"></p></li><li><p>_class_lookupMethodAndLoadCache3方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lookUpImpOrForward方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                   bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    // Optimistic cache lookup</span><br><span class="line">    if (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // runtimeLock is held during isRealized and isInitialized checking</span><br><span class="line">    // to prevent races against concurrent realization.</span><br><span class="line"></span><br><span class="line">    // runtimeLock is held during method search to make</span><br><span class="line">    // method-lookup + cache-fill atomic with respect to method addition.</span><br><span class="line">    // Otherwise, a category could be added but ignored indefinitely because</span><br><span class="line">    // the cache was re-filled with the old value after the cache flush on</span><br><span class="line">    // behalf of the category.</span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        // runtimeLock may have been dropped but is now locked again</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        // runtimeLock may have been dropped but is now locked again</span><br><span class="line"></span><br><span class="line">        // If sel == initialize, class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&apos;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Try this class&apos;s cache.</span><br><span class="line"></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line"></span><br><span class="line">    // Try this class&apos;s method lists.</span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try superclass caches and method lists.</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts = unreasonableClassCount();</span><br><span class="line">        for (Class curClass = cls-&gt;superclass;</span><br><span class="line">            curClass != nil;</span><br><span class="line">            curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            // Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts == 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Superclass cache.</span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                if (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    // Found the method in a superclass. Cache it in this class.</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // Found a forward:: entry in a superclass.</span><br><span class="line">                    // Stop searching, but don&apos;t cache yet; call method </span><br><span class="line">                    // resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Superclass method list.</span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        // Don&apos;t cache the result; we don&apos;t hold the lock so it may have </span><br><span class="line">        // changed already. Re-do the search from scratch instead.</span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // No implementation found, and method resolver didn&apos;t help. </span><br><span class="line">    // Use forwarding.</span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="从类的方法列表开始查找，没有就找父类，直到NSObject的父类nil"><a href="#从类的方法列表开始查找，没有就找父类，直到NSObject的父类nil" class="headerlink" title="从类的方法列表开始查找，没有就找父类，直到NSObject的父类nil"></a>从类的方法列表开始查找，没有就找父类，直到NSObject的父类nil</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">imp = cache_getImp(cls, sel);</span><br><span class="line">if (imp) goto done;</span><br><span class="line"></span><br><span class="line">// Try this class&apos;s method lists.</span><br><span class="line">&#123;</span><br><span class="line">    Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    if (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>在这里放上一张描述查找流程的经典图<br><img src="class.jpg" alt="class">  </li></ul><h2 id="动态方法解析流程"><a href="#动态方法解析流程" class="headerlink" title="动态方法解析流程"></a>动态方法解析流程</h2><h3 id="resolveMethod"><a href="#resolveMethod" class="headerlink" title="resolveMethod"></a>resolveMethod</h3><ul><li><p>以上方法都没有找到则进入resolveMethod</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    resolveMethod(cls, sel, inst);</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">    <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resolveMethod方法实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="resolveInstanceMethod"><a href="#resolveInstanceMethod" class="headerlink" title="resolveInstanceMethod"></a>resolveInstanceMethod</h3><ul><li>如果不是元类，使用resolveInstanceMethod拦截处理消息，元类调用resolveClassMethod<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveInstanceMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                        NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                        <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                        cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                        cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                        <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                        cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                        cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                        cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h2><blockquote><p>以上都没有找到，接下来进入消息转发流程，将消息交给其他类进行处理  </p></blockquote><h3 id="objc-msgForward-impcache"><a href="#objc-msgForward-impcache" class="headerlink" title="_objc_msgForward_impcache"></a>_objc_msgForward_impcache</h3><ul><li>在之前的流程（lookUpImpOrForward）结尾看到还存在消息转发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// No implementation found, and method resolver didn&apos;t help. </span><br><span class="line">// Use forwarding.</span><br><span class="line"></span><br><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure></li></ul><h3 id="在Crash前可使用forwardingTargetForSelector，通过其他类处理消息（Foundation框架）"><a href="#在Crash前可使用forwardingTargetForSelector，通过其他类处理消息（Foundation框架）" class="headerlink" title="在Crash前可使用forwardingTargetForSelector，通过其他类处理消息（Foundation框架）"></a>在Crash前可使用forwardingTargetForSelector，通过其他类处理消息（Foundation框架）</h3><ul><li>程序Crash截图<br><img src="forward.jpg" alt="forward">  </li><li>__forwarding__的函数实现    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数：前者为被转发消息的栈指针 IMP ，后者为是否返回结构体</span></span><br><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">  id receiver = *(id *)frameStackPointer;</span><br><span class="line">  SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">  Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">  <span class="comment">// 进入 备援接收 主要步骤</span></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">    <span class="comment">// 获得方法签名</span></span><br><span class="line">    id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">    <span class="comment">// 判断返回类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwarding != receiver) &#123;</span><br><span class="line">        <span class="comment">// 判断类型，是否返回值为结构体，选用不同的转发方法</span></span><br><span class="line">        <span class="keyword">if</span> (isStret == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 僵尸对象</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(receiverClass);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *zombiePrefix = <span class="string">"_NSZombie_"</span>;</span><br><span class="line">  <span class="keyword">size_t</span> prefixLen = <span class="built_in">strlen</span>(zombiePrefix); <span class="comment">// 0xa</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">    CFLog(kCFLogLevelError,</span><br><span class="line">          @<span class="string">"*** -[%s %s]: message sent to deallocated instance %p"</span>,</span><br><span class="line">          className + prefixLen,</span><br><span class="line">          selName,</span><br><span class="line">          receiver);</span><br><span class="line">    &lt;breakpoint-interrupt&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">  <span class="comment">// 进入消息转发系统</span></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">    <span class="comment">// 判断返回类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">      BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">      <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @<span class="string">"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s."</span>,</span><br><span class="line">              selName,</span><br><span class="line">              signatureIsStret ? <span class="string">""</span> : <span class="keyword">not</span>,</span><br><span class="line">              isStret ? <span class="string">""</span> : <span class="keyword">not</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">        <span class="comment">// 传入消息的全部细节信息</span></span><br><span class="line">        NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">        [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">        [invocation getReturnValue:&amp;value];</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @<span class="string">"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message"</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// selector 是否已经在 Runtime 注册过</span></span><br><span class="line">  <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">    CFLog(kCFLogLevelWarning ,</span><br><span class="line">          @<span class="string">"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort"</span>,</span><br><span class="line">          sel,</span><br><span class="line">          selName,</span><br><span class="line">          registeredSel);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// doesNotRecognizeSelector，主动抛出异常</span></span><br><span class="line">  <span class="comment">// 也就是前文我们看到的</span></span><br><span class="line">  <span class="comment">// 表明选择子未能得到处理</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">    [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    CFLog(kCFLogLevelWarning ,</span><br><span class="line">          @<span class="string">"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort"</span>,</span><br><span class="line">          receiver,</span><br><span class="line">          className);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The point of no return.</span></span><br><span class="line">  kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="消息转发可拦截函数整理"><a href="#消息转发可拦截函数整理" class="headerlink" title="消息转发可拦截函数整理"></a>消息转发可拦截函数整理</h3><ul><li>- (id)forwardingTargetForSelector:(SEL)aSelector  </li><li>- (NSMethodSignature)methodSignatureForSelector:(SEL)aSelector  </li><li>- (void)forwardInvocation:(NSInvocation)anInvocation  </li></ul><h2 id="消息无法处理"><a href="#消息无法处理" class="headerlink" title="消息无法处理"></a>消息无法处理</h2><pre><code>以上流程消息都没有被处理，最终调用-[NSObject(NSObject) doesNotRecognizeSelector:]，应用程序Crash<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[CYWatermelon genFoodName]: unrecognized selector sent to instance 0x100f3d270'</span><br><span class="line">*** First <span class="keyword">throw</span> call <span class="built_in">stack</span>:</span><br><span class="line">(</span><br><span class="line">  <span class="number">0</span>   CoreFoundation                      <span class="number">0x00007fff2e915193</span> __exceptionPreprocess + <span class="number">250</span></span><br><span class="line">  <span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x000000010038b73f</span> objc_exception_throw + <span class="number">47</span></span><br><span class="line">  <span class="number">2</span>   CoreFoundation                      <span class="number">0x00007fff2e99ebe6</span> -[NSObject(NSObject) __retain_OA] + <span class="number">0</span></span><br><span class="line">  <span class="number">3</span>   CoreFoundation                      <span class="number">0x00007fff2e8bb6f9</span> ___forwarding___ + <span class="number">1427</span></span><br><span class="line">  <span class="number">4</span>   CoreFoundation                      <span class="number">0x00007fff2e8bb0d8</span> _CF_forwarding_prep_0 + <span class="number">120</span></span><br><span class="line">  <span class="number">5</span>   CYLearnMsgSend                      <span class="number">0x0000000100000d01</span> main + <span class="number">81</span></span><br><span class="line">  <span class="number">6</span>   libdyld.dylib                       <span class="number">0x00007fff65a8c2a5</span> start + <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看汇编代码执行&quot;&gt;&lt;a href=&quot;#查看汇编代码执行&quot; class=&quot;headerlink&quot; title=&quot;查看汇编代码执行&quot;&gt;&lt;/a&gt;查看汇编代码执行&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;正常断点到我们的自定义调用再点击下一步这个方法调用流程就结束了，那
      
    
    </summary>
    
    
      <category term="底层探索" scheme="http://confiwang.github.io/categories/%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Runtime" scheme="http://confiwang.github.io/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C深拷贝&amp;浅拷贝</title>
    <link href="http://confiwang.github.io/2019/09/13/Objective-C%E6%B7%B1%E6%8B%B7%E8%B4%9D&amp;%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://confiwang.github.io/2019/09/13/Objective-C%E6%B7%B1%E6%8B%B7%E8%B4%9D&amp;%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2019-09-13T04:38:44.000Z</published>
    <updated>2019-09-13T06:02:44.200Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本文的灵感来自于一次代码风格纠错"><a href="#本文的灵感来自于一次代码风格纠错" class="headerlink" title="本文的灵感来自于一次代码风格纠错"></a>本文的灵感来自于一次代码风格纠错</h4><p>偶然间看到这篇blog（<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="noopener">招聘一个靠谱的 iOS</a>），好奇就做了一下其中的题目，没想到越写越多，那么就试着把这个过程整理出来，下面就是在实践过程中编写的代码。经过简单的注释，希望大家可以看懂~</p><p><img src="style_error.png" alt="style_error">  </p><h4 id="主要结论"><a href="#主要结论" class="headerlink" title="主要结论"></a>主要结论</h4><p>苹果没有提供对对象中所有属性进行完全深拷贝的方式，需要自己编写</p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>测试代码主要实践了各种拷贝方式的递归拷贝程度，并且对某些基础概念做了解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  WCLearnTest</span><br><span class="line">//</span><br><span class="line">//  Created by confiwang on 2019/9/11.</span><br><span class="line">//  Copyright © 2019 TencentJobs. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, CYUserSex) &#123;//指定枚举类型，代码更安全，如需使用位操作，可以使用NS_OPTIONS(&lt;#_type#&gt;, &lt;#_name#&gt;)替代</span><br><span class="line">    CYUserSexDefault,</span><br><span class="line">    CYUserSexMan,</span><br><span class="line">    CYUserSexWoman</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface CYUserInfo : NSObject&lt;NSCopying, NSMutableCopying&gt;//单一职责原则，并支持copy</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *name;//注意这边没有使用strong，NSString是只读的，但是可以指向NSMutableString，我们希望即使当他指向NSMutableString，后续的行为也是只读的</span><br><span class="line">@property(nonatomic, assign) NSUInteger age;</span><br><span class="line">@property(nonatomic, assign) CYUserSex sex;</span><br><span class="line">@property(nonatomic, strong) NSMutableSet *friends;//注意这边没有使用copy，可变集合使用copy后，会转成NSSet，导致对集合进行增删操作时的crash</span><br><span class="line"></span><br><span class="line">- (instancetype)initUserInfoWithName:(NSString *)name age:(NSUInteger)age sex:(CYUserSex)sex;</span><br><span class="line">- (instancetype)initUserInfoWithName:(NSString *)name age:(NSUInteger)age sex:(CYUserSex)sex friends:(NSMutableSet *)friends;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CYUserInfo</span><br><span class="line"></span><br><span class="line">- (instancetype)initUserInfoWithName:(NSString *)name age:(NSUInteger)age sex:(CYUserSex)sex &#123;</span><br><span class="line">    return [self initUserInfoWithName:name age:age sex:sex friends:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initUserInfoWithName:(NSString *)name age:(NSUInteger)age sex:(CYUserSex)sex friends:(NSMutableSet *)friends &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _age = age;</span><br><span class="line">        _sex = sex;</span><br><span class="line">        _friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    CYUserInfo *userInfo = [[[self class] allocWithZone:zone] initUserInfoWithName:_name age:_age sex:_sex];//[self class]如果方法被子类重新也可以支持</span><br><span class="line">    userInfo.friends = [_friends mutableCopy];//只支持单层的深拷贝，如果数组中元素存的是对象，则对象没有被拷贝</span><br><span class="line">    return userInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    CYUserInfo *userInfo = [[[self class] allocWithZone:zone] initUserInfoWithName:_name age:_age sex:_sex];//[self class]如果方法被子类重新也可以支持</span><br><span class="line">    userInfo.friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];//支持对数组对象调用深拷贝，但对数组对象中的数组对象中的对象仍为浅拷贝，这时候只能把写这个代码的人拖出去砍了。。。（否则需要使用复杂的方式保证递归拷贝所有对象）</span><br><span class="line">    return userInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;name:%@ age:%lu friends:%@&quot;, _name, _age, _friends];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    </span><br><span class="line">    CYUserInfo *yangpeng = [[CYUserInfo alloc] initUserInfoWithName:@&quot;yangpeng&quot; age:28 sex:CYUserSexMan];</span><br><span class="line">    CYUserInfo *panlei = [[CYUserInfo alloc] initUserInfoWithName:@&quot;panlei&quot; age:29 sex:CYUserSexMan];</span><br><span class="line">    CYUserInfo *huaidan = [[CYUserInfo alloc] initUserInfoWithName:@&quot;huaidan&quot; age:100 sex:CYUserSexMan];//坏蛋总是比较长寿</span><br><span class="line">    CYUserInfo *userInfo = [[CYUserInfo alloc] initUserInfoWithName:@&quot;confiwang&quot; age:26 sex:CYUserSexMan];</span><br><span class="line">    </span><br><span class="line">    NSMutableSet *confiFriends = [[NSMutableSet alloc] initWithObjects:panlei, yangpeng, nil];//创建的set数组没有对panlei进行拷贝</span><br><span class="line">    NSMutableSet *yangpengFriends = [[NSMutableSet alloc] initWithObjects:huaidan, nil];//朋友交往的都是坏蛋，因为跟我交往description会死循环</span><br><span class="line">    NSMutableSet *panleiFriends = [[NSMutableSet alloc] initWithObjects:huaidan,  nil];</span><br><span class="line">    </span><br><span class="line">    userInfo.friends = confiFriends;</span><br><span class="line">    panlei.friends = panleiFriends;</span><br><span class="line">    yangpeng.friends = yangpengFriends;</span><br><span class="line">    </span><br><span class="line">    CYUserInfo *userInfoBackup = [userInfo copy];</span><br><span class="line">    CYUserInfo *userInfoBackupMutable = [userInfo mutableCopy];</span><br><span class="line">    </span><br><span class="line">    [userInfo.friends addObject:huaidan];</span><br><span class="line">    </span><br><span class="line">    NSEnumerator *friendsEnumerator = [userInfo.friends objectEnumerator];//遍历</span><br><span class="line">    CYUserInfo *friendInfo;</span><br><span class="line">    CYUserInfo *huaidanInfo = nil;</span><br><span class="line">    while (friendInfo = [friendsEnumerator nextObject]) &#123;</span><br><span class="line">        if (friendInfo.name &amp;&amp; ![friendInfo.name isEqualToString: @&quot;huaidan&quot;]) &#123;</span><br><span class="line">            if (huaidanInfo) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            huaidanInfo = friendInfo;</span><br><span class="line">            huaidanInfo.name = [NSString stringWithFormat:@&quot;%@_edited&quot;, huaidanInfo.name];//修改成功名字加上edited标记</span><br><span class="line">            huaidanInfo.age = 1000;//贻害祸千年</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    friendInfo.name = [NSString stringWithFormat:@&quot;%@_edited&quot;, friendInfo.name];//修改成功名字加上edited标记</span><br><span class="line">    </span><br><span class="line">    [confiFriends removeAllObjects];//不影响backup结果，对集合都进行了浅拷贝</span><br><span class="line"></span><br><span class="line">    //=====================================================================</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;user:%@, friends:%@&quot;, userInfoBackup.name, userInfoBackup.friends);</span><br><span class="line">    /*运行结果：user:confiwang, friends:&#123;(</span><br><span class="line">                                            name:panlei_edited age:29 friends:&#123;(//看到数组中元素被修改</span><br><span class="line">                                                name:huaidan_edited age:1000 friends:(null)</span><br><span class="line">                                            )&#125;,</span><br><span class="line">                                            name:yangpeng age:28 friends:&#123;(</span><br><span class="line">                                                name:huaidan_edited age:1000 friends:(null)</span><br><span class="line">                                            )&#125;</span><br><span class="line">                                        )&#125;*/</span><br><span class="line">    //=====================================================================</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;user:%@, friends:%@&quot;, userInfoBackupMutable.name, userInfoBackupMutable.friends);</span><br><span class="line">    /*运行结果：user:confiwang, friends:&#123;(</span><br><span class="line">                                            name:panlei age:29 friends:&#123;(//数组中的元素不受影响</span><br><span class="line">                                                name:huaidan_edited age:1000 friends:(null)//数组中元素保存的数组中的对象被修改（两级数组中的对象被修改）</span><br><span class="line">                                            )&#125;,</span><br><span class="line">                                            name:yangpeng age:28 friends:&#123;(</span><br><span class="line">                                                name:huaidan_edited age:1000 friends:(null)</span><br><span class="line">                                            )&#125;</span><br><span class="line">                                        )&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;本文的灵感来自于一次代码风格纠错&quot;&gt;&lt;a href=&quot;#本文的灵感来自于一次代码风格纠错&quot; class=&quot;headerlink&quot; title=&quot;本文的灵感来自于一次代码风格纠错&quot;&gt;&lt;/a&gt;本文的灵感来自于一次代码风格纠错&lt;/h4&gt;&lt;p&gt;偶然间看到这篇blog（&lt;a
      
    
    </summary>
    
    
      <category term="基础知识" scheme="http://confiwang.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Objective-C" scheme="http://confiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>macOS APP内存优化</title>
    <link href="http://confiwang.github.io/2019/08/29/macOS-APP%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://confiwang.github.io/2019/08/29/macOS-APP%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2019-08-29T05:35:06.000Z</published>
    <updated>2019-09-01T09:14:24.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>我们为什么减少内存占用？</p><blockquote><p>为了更好的用户体验   </p></blockquote><p> 内存是有限且系统共享的资源，一个程序占用更多，系统和其他程序所能用的就更少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也需要占用一定的内存资源。减少内存占用也能同时减少其对 CPU 时间维度上的消耗，从而使不仅你所开发的 App，其他 App 以及整个系统也都能表现的更好。</p></li><li><p>可以减少的内存占用有哪些？</p><blockquote><p>从苹果的开发者文档里可以看到，一个 app 的内存分三类：</p><ul><li>Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).</li><li>Abandoned memory: Memory still referenced by your application that has no useful purpose.</li><li>Cached memory: Memory still referenced by your application that might be used again for better performance.  </li></ul></blockquote><p> 之前在做后台开发的时候解决最多的问题就是Leaked memory，但是在客户端开发的时候会发现，Abandoned memory跟Cached memory渐渐地成为了内存消耗的主力</p></li><li><p>如何选取内存占用指标？</p><blockquote><ul><li>系统APP 活动监视器-内存  </li><li>terminal 使用footprint命令  </li><li>objective-c 使用task_vm_info_data_t中的phys_footprint  </li></ul></blockquote><p> 以上三种方式能得到相似的结果，也是WWDC2013 704 Building Efficient OS X Apps推荐的内存占用获取方式，附上最后一种方式的代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task_vm_info_data_t</span> task_infos = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">info_count = TASK_VM_INFO_COUNT;</span><br><span class="line"><span class="keyword">if</span> (task_info(mach_task_self(), TASK_VM_INFO, (<span class="keyword">task_info_t</span>)&amp;task_infos, &amp;info_count) == KERN_SUCCESS) &#123;</span><br><span class="line">    memory_footprint = task_infos.phys_footprint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><ol><li><p>静态代码扫描</p><ul><li>Xcode自带Analyze<br>   适合检查leaked memory，对malloc或者new方式分配的内存或者未定义的变量等检查效果较好</li></ul></li><li><p>MLeaksFinder</p><ul><li>适合检查如NSViewController被释放了了，但它的view没被释放，或者一个NSView被释放了了，但它的某个subview没被释放。对手机上频繁切换页面的APP优化效果明显。</li></ul></li><li><p>微信内存监控</p><blockquote><p>Matrix-iOS 当前工具监控范围包括：崩溃、卡顿和爆内存，包含以下两款插件：  </p><ul><li>WCCrashBlockMonitorPlugin： 基于 KSCrash 框架开发，具有业界领先的卡顿堆栈捕获能力，同时兼备崩溃捕获能力。  </li><li>WCMemoryStatPlugin： 一款性能优化到极致的爆内存监控工具，能够全面捕获应用爆内存时的内存分配以及调用堆栈情况。  </li></ul></blockquote><p> 内存这块主要使用WCMemoryStatPlugin，得到的内存分配文件相比较与Instruments有部分数据缺失，需要自己编写脚本符号化得到的内存分配文件，适合监控线上的内存情况，可以发现一些偶现的内存问题</p></li><li><p>Instruments leaks<br> <img src="Instruments-Leaks-Test.jpg" alt="Instruments-Leaks-Test"></p><ul><li>可以看到单纯的内存泄露并不多，看来大都属于在运行过程中不断的申请内存，但是在很长一段时间内没有释放，或者是直到程序退出时，才释放申请的内存。</li></ul></li><li><p>Instruments Allocations</p><ul><li>可以看到自应用开始详细的内存分配，不过占用空间过大，不能持续运行。</li></ul></li><li><p>Memory Graph  </p><ul><li>它对比Instruments Allocations，开启后不会迅速产生大量日志文件，导致应用程序卡死。而且他提供丰富的命令，几乎涵盖了，Instruments中Allocations跟leaks的所有功能，并且使用命令对当前应用程序中分配的内存类型等进行简单的统计分析，快速的定位应用程序中分配最多的内存是什么，以及是如何分配的很方便。</li></ul></li></ol><h2 id="内存优化的方法论"><a href="#内存优化的方法论" class="headerlink" title="内存优化的方法论"></a>内存优化的方法论</h2><ol><li>在介绍了上述几种工具之后，我还希望可以借助一些工具，对内存占用进行一些分析操作，比如对分配的内存进行分类，排序，查看其分配堆栈，查看其被谁持有。<br>左图就是由此产生的内存问题分析方法，具体操作是打开APP，持续使用，期间可以随时导出Memory Graph文件，使用VMMap查看文件，对文件中的内存分配进行分类排序，取其中分配最大的一块内存的首地址使用Malloc_History跟Leaks进行分析，可以得到这块内存分配的详细堆栈以及当前是被谁引用，接下来就是对这块内存进行优化，通过不断的优化当前内存分配的大头，带来APP内存的巨大下降。<br><img src="methodology.jpg" alt="methodology">  </li></ol><h3 id="通过上述方法进行分析，发现APP中内存占用几个大类"><a href="#通过上述方法进行分析，发现APP中内存占用几个大类" class="headerlink" title="通过上述方法进行分析，发现APP中内存占用几个大类"></a>通过上述方法进行分析，发现APP中内存占用几个大类</h3><ol><li>界面的渲染</li><li>图片的压缩</li><li>各种缓存</li><li>bug</li></ol><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><blockquote><h3 id="接下来我们逐个分析，介绍APP的内存占用"><a href="#接下来我们逐个分析，介绍APP的内存占用" class="headerlink" title="接下来我们逐个分析，介绍APP的内存占用"></a>接下来我们逐个分析，介绍APP的内存占用</h3></blockquote><h4 id="界面的渲染"><a href="#界面的渲染" class="headerlink" title="界面的渲染"></a>界面的渲染</h4><ol><li>view的定制通过重写drawrect消耗大量内存  </li></ol><ul><li>为何重写drawrect消耗大量内存<br>  当我们重写drawrect时，会促使Core Animation创建一个Open GL纹理，并将你使用CoreGraphics框架的绘图操作数据放到纹理的位图数据中。<br>  <img src="backing-store.png" alt="backing-store"><br>  计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。当我们重写drawrect时，CPU会创建backing-store进行渲染，随后拷贝到GPU的显存（VRAM）<br>  <img src="drawrect.png" alt="drawrect"><br>  上图就是一个BackingStore的绘制过程，首先是window窗口触发重绘，准备重绘区域等大的一个基于bitmap的上下文，然后从父view开始，遍历所有的子view进行层层绘制，每一个绘制操作完成之后，才开始下一个绘制。<br>  观察drawRect方法，如发现是一些点线条，背景色等的绘制，我们就可以使用CAShapeLayer+CGPath的方式进行绘制，CAShapeLayer是苹果提供的一个对opengl es的一个封装，可以完全满足我们的需要。<br>  <img src="CAShapeLayer.png" alt="CAShapeLayer"><br>  上图就是使用CAShapeLayer+CGPath的绘制方式替换之前通过Core Graphics的绘制方式的流程对比，一个CAShapeLayer 不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。并且CAShapeLayer渲染快速，使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li></ul><ul><li>离屏渲染介绍<br>  首先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区，其中涉及到两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。可以直接将图层合成到帧的缓冲区中(在屏幕上);当帧缓冲区图片被复用的时候，可以提升性能。  <ul><li>帧缓冲区介绍<br>帧缓冲区(显存或者内存上一段空间)：是由像素组成的二维数组，每一个存储单元对应屏幕上的一个像素，整个帧缓冲对应一帧图像即当前屏幕画面。帧缓冲通常包括：颜色缓冲，深度缓冲，模板缓冲和累积缓冲。这些缓冲区可能是在一块内存区域，也可能单独分开，看硬件。  </li></ul></li><li>Core Animation介绍<br>  Core Animation的核心是OpenGL ES的一个抽象物，Core Animation的layer对应着OpenGL ES的texture，Core Animation可以有子layer，所以我们能看到他是一个图层树。在图像显示过程中，Core Animation的主要任务是判断出哪些图层需要被(重新)绘制，然后交由OpenGL ES将这些图层合并、显示到屏幕上。  </li></ul><h4 id="图片的压缩"><a href="#图片的压缩" class="headerlink" title="图片的压缩"></a>图片的压缩</h4><ol><li><p>减少图片压缩产生的内存占用峰值</p><ul><li><p>图片的压缩逻辑改造<br>使用ImageIO方式对图片进行压缩，无需解码bitmap<br><img src="image-io.png" alt="image-io-replace"><br>下面附上实现代码  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary* options = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[options safeSetObject:(__bridge id)kCFBooleanTrue forKey:(__bridge id)kCGImageSourceCreateThumbnailFromImageAlways];</span><br><span class="line">[options safeSetObject:(__bridge id)kCFBooleanTrue forKey:(__bridge id)kCGImageSourceCreateThumbnailWithTransform];</span><br><span class="line">[options safeSetObject:(__bridge id)kCFBooleanFalse forKey:(__bridge id)kCGImageSourceShouldCache];</span><br><span class="line">[options safeSetObject:[NSNumber numberWithFloat:maxPixelSize] forKey:(__bridge id)kCGImageSourceThumbnailMaxPixelSize];</span><br><span class="line"></span><br><span class="line">CGImageSourceRef sourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)imageData, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="各种缓存"><a href="#各种缓存" class="headerlink" title="各种缓存"></a>各种缓存</h4><ol><li>减少APP内缓存  <ul><li>减少单个缓存的大小  </li><li>减少缓存时间，及时释放  </li><li>减少缓存数量  </li></ul></li></ol><h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><ol><li>bug修复  </li></ol><p>推荐阅读：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">WWDC-iOS Memory Deep Dive</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2012/506/" target="_blank" rel="noopener">WWDC-Optimizing 2D Graphics and Animation Performance</a></li><li><a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a></li><li><a href="https://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="noopener">微信读书博客</a></li><li><a href="https://github.com/Tencent/matrix#matrix_ios_cn" target="_blank" rel="noopener">微信内存监控开源项目-Matrix</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们为什么减少内存占用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了更好的用户体验   &lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://confiwang.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="macOS" scheme="http://confiwang.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://confiwang.github.io/2019/08/29/hello-world/"/>
    <id>http://confiwang.github.io/2019/08/29/hello-world/</id>
    <published>2019-08-29T03:33:06.000Z</published>
    <updated>2019-09-13T06:08:37.600Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Cleans-the-cache-file-and-generated-files"><a href="#Cleans-the-cache-file-and-generated-files" class="headerlink" title="Cleans the cache file and generated files"></a>Cleans the cache file and generated files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/commands#clean" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
      <category term="hello" scheme="http://confiwang.github.io/tags/hello/"/>
    
  </entry>
  
</feed>
